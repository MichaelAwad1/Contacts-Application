export declare const arrays: {
    /**
     * Ensures the given parameter is an array.
     */
    ensure<T>(array: T | T[]): T[];
    /**
     * Creates an array with the given length and initializes each value with the given initValue.
     */
    init<T_1>(length: number, initValue: T_1): T_1[];
    /**
     * Removes the first occurrence of the specified element from the array,
     * if it is present (optional operation). If the array does not contain
     * the element, it is unchanged.
     *
     * @returns true if the array contained the specified element
     */
    remove<T_2>(arr: T_2[], element: T_2): boolean;
    /**
     * Removes every given element from the array
     *
     * @returns true if the array contained at least one of the specified elements
     */
    removeAll<T_3>(arr: T_3[], elements: T_3[]): boolean;
    /**
     * @returns the index of the replaced element
     */
    replace<T_4>(arr: T_4[], element: T_4, replacement: T_4): number;
    /**
     * Inserts the given element at the specified index.
     * <p>
     * This function uses {@link insertAll} which relies on Array.prototype.splice(). Check its js-doc for details.
     */
    insert<T_5>(arr: T_5[], element: T_5, index: number): void;
    /**
     * Inserts all elements of the given array at the specified index.
     *
     * This function is based on Array.prototype.splice().
     * Thus, if the 'index' is greater than the length of the array, 'elements' will be added to the end of the array 'arr'.
     * This may cause unexpected behavior on accessing arr[index] after insertion.
     *
     * The caller must ensure the size of the array.
     */
    insertAll<T_6>(arr: T_6[], elements: T_6 | T_6[], index: number): void;
    /**
     * Inserts the given element into the array according to the sort order indicated by the given comparison function.
     *
     * All arguments are mandatory.
     */
    insertSorted<T_7>(arr: T_7[], element: T_7, compareFunc: (a: T_7, b: T_7) => number): void;
    /**
     * Inserts to given element into the array directly BEFORE the first array element that matches the given predicate.
     * If no such element can be found, the new element is inserted at the BEGINNING of the array.
     *
     * @param thisArg optional "this" binding for predicate function
     */
    insertBefore<T_8>(arr: T_8[], elementToInsert: T_8, predicate: (elem: T_8, index: number, arr: T_8[]) => boolean, thisArg?: any): void;
    /**
     * Inserts to given element into the array directly AFTER the first array element that matches the given predicate.
     * If no such element can be found, the new element is inserted at the END of the array.
     */
    insertAfter<T_9>(arr: T_9[], elementToInsert: T_9, predicate: (elem: T_9, index: number, arr: T_9[]) => boolean): void;
    /**
     * This function uses {@link insert} which relies on Array.prototype.splice(). Check its js-doc for details.
     */
    move<T_10>(arr: T_10[], fromIndex: number, toIndex: number): void;
    contains<T_11>(haystack: T_11[], needle: T_11): boolean;
    containsAny<T_12>(haystack: T_12 | T_12[], needles: T_12 | T_12[]): boolean;
    containsAll<T_13>(haystack: T_13 | T_13[], needles: T_13 | T_13[]): boolean;
    first<T_14>(arr: T_14[]): T_14;
    last<T_15>(arr: T_15[]): T_15;
    /**
     * @returns true if the given argument is an array and has a length > 0, false in any other case.
     */
    hasElements<T_16>(arr: T_16 | T_16[]): boolean;
    /**
     * @returns true if the given argument is not an array or the length of the array is 0, false in any other case.
     */
    empty<T_17>(arr: T_17 | T_17[]): boolean;
    /**
     * @returns the size of the array, or 0 if the argument is not an array
     */
    length<T_18>(arr: T_18 | T_18[]): number;
    pushAll<T_19>(arr: T_19[], arr2: T_19 | T_19[]): void;
    /**
     * Merges the two given arrays and removes duplicate entries in O(n).
     * If the arrays contain objects instead of primitives, it uses their id to check for equality.
     */
    union<T_20 extends string | number | {
        id: string;
    }>(array1: T_20[], array2: T_20[]): T_20[];
    equalsIgnoreOrder(arr: any[], arr2: any[]): boolean;
    equals(arr: ArrayLike<any>, arr2: ArrayLike<any>): boolean;
    greater(arr: [], arr2: []): boolean;
    eachSibling<T_21>(arr: ArrayLike<T_21>, element: T_21, func: (elem: T_21, index: number) => void): void;
    /**
     * Alternative implementation of Array.findIndex(callback [, thisArg]), which is supported by most browsers.
     * See Array.findIndex for a detailed description.
     *
     * @param optional "this" binding for predicate function
     */
    findIndex<T_22>(arr: ArrayLike<T_22>, predicate: (elem: T_22, index: number, arr: T_22[]) => boolean, thisArg?: any): number;
    /**
     *
     * @param thisArg optional "this" binding for predicate function
     */
    find<T_23>(arr: ArrayLike<T_23>, predicate: (elem: T_23, index: number, arr: T_23[]) => boolean, thisArg?: any): T_23;
    findFrom<T_24>(arr: ArrayLike<T_24>, startIndex: number, predicate: (elem: T_24, index: number) => boolean, reverse?: boolean): T_24;
    findIndexFrom<T_25>(arr: ArrayLike<T_25>, startIndex: number, predicate: (elem: T_25, index: number) => boolean, reverse?: boolean): number;
    findFromForward<T_26>(arr: ArrayLike<T_26>, startIndex: number, predicate: (elem: T_26, index: number) => boolean): T_26;
    findIndexFromForward<T_27>(arr: ArrayLike<T_27>, startIndex: number, predicate: (elem: T_27, index: number) => boolean): number;
    findFromReverse<T_28>(arr: ArrayLike<T_28>, startIndex: number, predicate: (elem: T_28, index: number) => boolean): T_28;
    findIndexFromReverse<T_29>(arr: ArrayLike<T_29>, startIndex: number, predicate: (elem: T_29, index: number) => boolean): number;
    /**
     * Pushes all elements to the given array that are not null or undefined.
     */
    pushIfDefined<T_30>(arr: T_30[], ...elements: T_30[]): void;
    /**
     * Pushes the given element if it does not already exist in the array and the element is truthy. Thus, the array is like a Set where every element
     * can only be added once to the collection. Note: the comparison is done with the === operator.
     */
    pushSet<T_31>(arr: T_31[], element: T_31): void;
    /**
     * Creates a string containing all elements in the array separated by the given delimiter.
     * @param encodeHtml true to encode the elements, false if not. Default is false
     */
    format(arr: ArrayLike<string>, delimiter?: string, encodeHtml?: boolean): string;
    formatEncoded(arr: ArrayLike<string>, delimiter?: string): string;
    max(arr: number[]): number;
    min(arr: number[]): number;
    /**
     * @returns all elements of the first array which are not in the second array
     */
    diff<T_32>(arr1: T_32[], arr2: T_32[]): T_32[];
    flatMap<T_33, R>(arr: T_33 | T_33[], func?: (T: any) => R | R[]): R[];
    /**
     * Returns a flat array of all elements and their recursive child elements.
     *
     * @param arr The top-level list of all elements
     * @param childrenAccessor Function than extracts a list of child elements from a given element. Used to traverse the object structure.
     */
    flattenRec<T_34>(arr: T_34[], childrenAccessor: (T: any) => T_34[]): T_34[];
    /**
     * Replacement for indexOf() that works for arrays of jQuery objects (compares DOM nodes).
     */
    $indexOf(arr: JQuery[], $element: JQuery): number;
    /**
     * Replacement for remove() that works for arrays of jQuery objects (compares DOM nodes).
     */
    $remove(arr: JQuery[], $element: JQuery): void;
    randomElement<T_35>(array: T_35[]): T_35;
    /**
     * Converts the given array to a map. For each element, key and value is determined by the given functions.
     * If no function is provided, the element itself is used.
     *
     * @param array array of elements
     * @param keyMapper function that maps each element to the target key
     * @param valueExtractor function that maps each element to the target value
     */
    toMap<T_36>(array: T_36[], keyMapper?: (el: T_36) => PropertyKey, valueMapper?: (el: T_36) => any): any;
    /**
     * If the argument is an empty array, null is returned. Otherwise, the argument is returned unchanged.
     */
    nullIfEmpty<T_37>(array: T_37[]): T_37[];
    /**
     * Clears the content of an array <i>in-place</i>. All elements are removed from the array and the
     * length will be set to 0. If the given argument is not an array, nothing happens.
     *
     * This is a more readable version of `array.splice(0, a.length)`.
     *
     * The return value is an array of all deleted elements (never null).
     */
    clear<T_38>(array: T_38[]): T_38[];
};
//# sourceMappingURL=arrays.d.ts.map