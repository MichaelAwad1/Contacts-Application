/// <reference types="jquery" />
import { EnumObject, InitModelOf, ObjectModel, ObjectWithType, Predicate } from '../index';
import TypeOrArray = JQuery.TypeOrArray;
interface DeviceModel extends ObjectModel<Device> {
    userAgent: string;
}
export type DeviceSystem = EnumObject<typeof Device.System>;
export type DeviceType = EnumObject<typeof Device.Type>;
export type DeviceBrowser = EnumObject<typeof Device.Browser>;
/**
 * Provides information about the device and its supported features.<p>
 * The information is detected lazily.
 *
 * @singleton
 */
export declare class Device implements DeviceModel, ObjectWithType {
    model: DeviceModel;
    objectType: string;
    userAgent: string;
    features: Record<string, boolean>;
    system: DeviceSystem;
    type: DeviceType;
    browser: DeviceBrowser;
    browserVersion: number;
    systemVersion: number;
    scrollbarWidth: number;
    constructor(model?: InitModelOf<Device>);
    static VENDOR_PREFIXES: readonly ["Webkit", "Moz", "O", "ms", "Khtml"];
    static Browser: {
        readonly UNKNOWN: "Unknown";
        readonly FIREFOX: "Firefox";
        /**
         * Chromium based: Google Chrome, Microsoft Edge, Brave, Opera
         */
        readonly CHROME: "Chrome";
        readonly INTERNET_EXPLORER: "InternetExplorer";
        /**
         * Only Legacy Edge. Chromium based Edge is reported as CHROME
         */
        readonly EDGE: "Edge";
        readonly SAFARI: "Safari";
    };
    static System: {
        readonly UNKNOWN: "Unknown";
        readonly IOS: "IOS";
        readonly ANDROID: "ANDROID";
        readonly WINDOWS: "WINDOWS";
    };
    static Type: {
        readonly DESKTOP: "DESKTOP";
        readonly TABLET: "TABLET";
        readonly MOBILE: "MOBILE";
    };
    /**
     * Called during bootstrap by index.html before the session startup.<p>
     * Precalculates the value of some attributes to store them
     * in a static way (and prevent many repeating function calls within loops).<p>
     * Also loads device specific scripts (e.g. fast click for ios devices)
     */
    bootstrap(): JQuery.Promise<any>[];
    protected _loadScriptDeferred(scriptUrl: string, doneFunc: TypeOrArray<JQuery.Deferred.Callback<JQuery>>): JQuery.Promise<JQuery>;
    /**
     * IOs does only trigger :active when touching an element if a touchstart listener is attached
     * Unfortunately, the :active is also triggered when scrolling, there is no delay.
     * To fix this we would have to work with a custom active class which will be toggled on touchstart/end
     */
    protected _installActiveHandler(): void;
    protected _needsIPhoneRotationHack(): boolean;
    /**
     * The iphone wants to activate the minimal-ui mode when it is rotated to landscape. This would actually be a good thing, but unfortunately it is buggy.
     * When the device is rotated there will be a white bar visible at the bottom of the screen.
     * When it is rotated back it may look ok at first but touching an element does not work anymore because the touch-point is about 30px at the wrong location.
     * <p>
     * This happens because the height used for layouting the desktop is smaller than it should be. This layouting is triggered by the window resize event, so obviously
     * the resize event comes too early and no resize event will be triggered when the minimal-ui mode is activated.
     * <p>
     * Unfortunately it is also not possible to schedule the relay outing after a rotation because the height does not seem to be reliable.
     * Even if the window or body size will explicitly be set to the viewport size, there will be a white bar at the bottom, even though the scout desktop is layouted with the correct size.
     * <p>
     * Luckily, it is possible to show the address bar programmatically, but we need to wait for the rotation animation to complete.
     * Since there is no event for that we need to try it several times, sometimes it will work after 150ms, sometimes we have to wait 250ms.
     * This is quite a hack and will likely break with a future ios release...
     */
    protected _fixIPhoneRotationBug(): void;
    orientation(): 'portrait' | 'landscape';
    hasOnScreenKeyboard(): boolean;
    /**
     * Returns if the current browser includes the padding-right-space in the scrollWidth calculations.<br>
     * Such a browser increases the scrollWidth only if the text-content exceeds the space <i>including</i> the right-padding.
     * This means the scrollWidth is equal to the clientWidth until the right-padding-space is consumed as well.
     */
    isScrollWidthIncludingPadding(): boolean;
    /**
     * Safari shows a tooltip if ellipsis are displayed due to text truncation. This is fine but, unfortunately, it cannot be prevented.
     * Because showing two tooltips at the same time (native and custom) is bad, the custom tooltip cannot be displayed.
     */
    isCustomEllipsisTooltipPossible(): boolean;
    /**
     * @returns true if the current device is an iPhone. This is more specific than the <code>isIos</code> function
     * which also includes iPads and iPods.
     */
    isIos(): boolean;
    isEdge(): boolean;
    /**
     * @returns 'ms-edge' if the current browser is Microsoft Edge
     */
    cssClassForEdge(): 'ms-edge' | '';
    /**
     * @returns 'iphone' if the current device is an iPhone
     */
    cssClassForIphone(): 'iphone' | '';
    isIphone(): boolean;
    isInternetExplorer(): boolean;
    isFirefox(): boolean;
    isChrome(): boolean;
    /**
     * Compared to isIos() this function uses {@link navigator.platform} instead of navigator.userAgent to check whether the app runs on iOS.
     * Most of the time isIos() is the way to go.
     * This function was mainly introduced to detect whether it is a real iOS or an emulated one (e.g. using chrome emulator).
     * @returns true if the platform is iOS, false if not (e.g. if chrome emulator is running)
     */
    isIosPlatform(): boolean;
    isAndroid(): boolean;
    /**
     * The best way we have to detect a Microsoft Surface Tablet in table mode is to check if
     * the scrollbar width is 0 pixel. In desktop mode the scrollbar width is > 0 pixel.
     */
    isWindowsTabletMode(): boolean;
    /**
     * @returns true if {@link navigator.standalone} is true which is the case for iOS home screen mode
     */
    isStandalone(): boolean;
    /**
     * This method returns false for all browsers that are known to be unsupported, all others (e.g. unknown engines) are allowed by default.
     * The supported browser versions are mainly determined by the features needed by Scout (e.g. class syntax, Array.flatMap, IntersectionObserver, Custom CSS Properties, CSS flex-box, queueMicrotask).
     */
    isSupportedBrowser(browser?: DeviceBrowser, version?: number): boolean;
    /**
     * Can not detect type until DOM is ready because we must create a DIV to measure the scrollbars.
     */
    protected _detectType(userAgent: string): DeviceType;
    protected _parseSystem(): void;
    /**
     * Currently only supports IOS
     */
    protected _parseSystemVersion(): void;
    protected _parseBrowser(): void;
    /**
     * Version regex only matches the first number pair
     * but not the revision-version. Example:
     * - 21     match: 21
     * - 21.1   match: 21.1
     * - 21.1.3 match: 21.1
     */
    protected _parseBrowserVersion(): void;
    protected _parseVersion(userAgent: string, versionRegex: RegExp): number;
    supportsFeature(property: string, checkFunc: Predicate<string>): boolean;
    /**
     * Currently this method should be used when you want to check if the device is "touch only" -
     * which means the user has no keyboard or mouse. Some hybrids like Surface tablets in desktop mode are
     * still touch devices, but support keyboard and mouse at the same time. In such cases this method will
     * return false, since the device is not touch only.
     *
     * Currently, this method returns the same as hasOnScreenKeyboard(). Maybe the implementation here will be
     * different in the future.
     */
    supportsOnlyTouch(): boolean;
    /**
     * @see http://www.stucox.com/blog/you-cant-detect-a-touchscreen/
     * @see https://codeburst.io/the-only-way-to-detect-touch-with-javascript-7791a3346685
     */
    supportsTouch(): boolean;
    supportsFile(): boolean;
    /**
     * Some browsers support the file API but don't support the File constructor (new File()).
     */
    supportsFileConstructor(): boolean;
    supportsCssAnimation(): boolean;
    /**
     * Used to determine if browser supports full history API.
     * Note that IE9 only partially supports the API, pushState and replaceState functions are missing.
     * @see: https://developer.mozilla.org/de/docs/Web/API/Window/history
     */
    supportsHistoryApi(): boolean;
    supportsCssGradient(): boolean;
    supportsInternationalization(): boolean;
    /**
     * Returns true if the device supports the download of resources in the same window as the single page app is running.
     * With "download" we mean: change <code>window.location.href</code> to the URL of the resource to download. Some browsers don't
     * support this behavior and require the resource to be opened in a new window with <code>window.open</code>.
     */
    supportsDownloadInSameWindow(): boolean;
    supportsWebcam(): boolean;
    supportsMicrotask(): boolean;
    supportsIntersectionObserver(): boolean;
    hasPrettyScrollbars(): boolean;
    canHideScrollbars(): boolean;
    supportsCopyFromDisabledInputFields(): boolean;
    /**
     * If the mouse down on an element with a pseudo-element removes the pseudo-element (e.g. check box toggling),
     * the firefox cannot focus the element anymore and instead focuses the body. In that case manual focus handling is necessary.
     */
    loosesFocusIfPseudoElementIsRemoved(): boolean;
    supportsCssProperty(property: string): boolean;
    supportsGeolocation(): boolean;
    /**
     * When we call .preventDefault() on a mousedown event Firefox doesn't apply the :active state.
     * Since W3C does not specify an expected behavior, we need this workaround for consistent behavior in
     * our UI. The issue has been reported to Mozilla, but it doesn't look like there will be a bugfix soon:
     *
     * https://bugzilla.mozilla.org/show_bug.cgi?id=771241#c7
     */
    requiresSyntheticActiveState(): boolean;
    supportsPassiveEventListener(): boolean;
    checkCssValue(property: string, value: string, checkFunc: Predicate<string>): boolean;
    /**
     *  https://bugs.chromium.org/p/chromium/issues/detail?id=740502
     */
    hasTableCellZoomBug(): boolean;
    protected _detectScrollbarWidth(cssClass?: string): number;
    toString(): string;
    static get(): Device;
}
export {};
//# sourceMappingURL=Device.d.ts.map