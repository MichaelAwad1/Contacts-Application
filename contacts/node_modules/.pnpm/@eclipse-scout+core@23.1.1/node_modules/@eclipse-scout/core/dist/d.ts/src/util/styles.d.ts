export interface Rgba {
    red: number;
    green: number;
    blue: number;
    alpha?: number;
}
export interface FontSpec {
    name?: string;
    size?: number;
    bold?: boolean;
    italic?: boolean;
}
export declare const styles: {
    styleMap: {};
    element: HTMLDivElement;
    /**
     * Generates an invisible div and appends it to the body, only once. The same div will be reused on subsequent calls.
     * Adds the given css class to that element and returns a style object containing the values for every given property.
     * The style is cached. Subsequent calls with the same css class will return the same style object.
     *
     * @param styleProperties in the form {backgroundColor: 'black'}
     */
    get(cssClass: string | string[], properties: string | string[], styleProperties?: Record<string, string>): Record<string, string>;
    /**
     * Traverses the parents of the given $elem and returns the first opaque background color.
     */
    getFirstOpaqueBackgroundColor($elem: JQuery<Element>): string;
    getSize(cssClass: string | string[], cssProperty: string | string[], property: string, defaultSize?: number): number;
    put(cssClass: string, style: Record<string, string>): void;
    clearCache(): void;
    RGB_BLACK: Rgba;
    RGB_WHITE: Rgba;
    /**
     * Creates a rgb object based on the given rgb string with the format rgb(0, 0, 0).
     * If the input string cannot be parsed, undefined is returned.
     */
    rgb(rgbString: string): Rgba;
    /**
     * Converts the given hex string to a rgb string.
     */
    hexToRgb(hexString: string): string;
    /**
     * Returns the given rgb color in hex format.
     *
     * @param rgba a color in rgb or rgba format
     * @param forceRemoveAlpha true, if the alpha value should be removed, otherwise false.
     * @returns the color in hex format
     */
    rgbToHex(rgba: string, forceRemoveAlpha?: boolean): string;
    /**
     * Make a given color darker by mixing it with a certain amount of black.
     * If no color is specified or the color cannot be parsed, undefined is returned.
     *
     * @param color
     *          a CSS color in 'rgb()' or 'rgba()' format.
     * @param ratio
     *          a number between 0 and 1 specifying how much black should be added
     *          to the given color (0.0 = only 'color', 1.0 = only black).
     *          Default is 0.2.
     */
    darkerColor(color: string, ratio?: number): string;
    /**
     * Make a given color lighter by mixing it with a certain amount of white.
     * If no color is specified or the color cannot be parsed, undefined is returned.
     *
     * @param color
     *          a CSS color in 'rgb()' or 'rgba()' format.
     * @param ratio
     *          a number between 0 and 1 specifying how much white should be added
     *          to the given color (0.0 = only 'color', 1.0 = only white).
     *          Default is 0.2.
     */
    lighterColor(color: string, ratio?: number): string;
    /**
     * Merges two RGB colors as defined by rgb().
     *
     * The two 'ratio' arguments specify "how much" of the corresponding color is added to the
     * resulting color. Both arguments should (but don't have to) add to 1.0.
     *
     * All arguments are mandatory.
     */
    mergeRgbColors(colorA: string | Rgba, ratio1?: number, colorB?: string | Rgba, ratio2?: number): string;
    /**
     * Example: Dialog-PLAIN-12
     */
    parseFontSpec(pattern: string): FontSpec;
    modelToCssColor(color: string): string;
    /**
     * Returns a string with CSS definitions for use in an element's "style" attribute. All CSS relevant
     * properties of the given object are converted to CSS definitions, namely foreground color, background
     * color and font.
     *
     * If an $element is provided, the CSS definitions are directly applied to the element. This can be
     * useful if the "style" attribute is shared and cannot be replaced in its entirety.
     *
     * If propertyPrefix is provided, the prefix will be applied to the properties, e.g. if the prefix is
     * 'label' the properties labelFont, labelBackgroundColor and labelForegroundColor are used instead of
     * just font, backgroundColor and foregroundColor.
     */
    legacyStyle(obj: object, $element?: JQuery, propertyPrefix?: string): string;
    legacyForegroundColor(obj: object, $element?: JQuery, propertyPrefix?: string): string;
    legacyBackgroundColor(obj: object, $element?: JQuery, propertyPrefix?: string): string;
    legacyFont(obj: object, $element?: JQuery, propertyPrefix?: string): string;
    _getElement(): HTMLDivElement;
};
//# sourceMappingURL=styles.d.ts.map