export interface AppendToTarget {
    id?: string;
    root: boolean;
}
export interface InsertTarget {
    id: string;
    root?: boolean;
    property?: string;
    before?: string;
    after?: string;
    index?: number;
    groupWithTarget?: boolean;
}
export interface AppendToAction {
    operation: string;
    target: AppendToTarget;
    extension: object;
}
export interface InsertAction {
    operation: string;
    target: InsertTarget;
    extension: object;
}
export type ExtensionAction = AppendToAction | InsertAction;
export interface ExtensionModel {
    id?: string;
    type?: string;
    extensions: ExtensionAction[];
}
declare function get<T>(modelFunc: () => T): T;
declare function get<T, P>(modelFunc: () => T, parent: P): T & {
    parent: P;
};
export declare const models: {
    modelMap: {};
    init(data: any): void;
    get: typeof get;
    /**
     * Returns a new instance of an extension from the global modelMap.
     *
     * @param extensionId The id of the extension.
     */
    getExtension(extensionId: string): ExtensionModel;
    /**
     * Returns a copy of the object in the global modelMap.
     *
     * @internal
     * @param id ID of the requested object (model or extension)
     * @param type Expected type of the requested object ('model' or 'extension')
     */
    _get(id: string, type: string): ExtensionModel;
    /**
     * Extends 'parentModel' with the contents of 'extension'.
     *
     * Parent model
     * ------------
     * The 'parentModel' argument (mandatory) will be changed and returned.
     *
     * Extension
     * ---------
     * Needs a property id on the parentModel to find the extension point.
     * Syntax of the extension:
     *
     * [appendTo]
     * Adding or overriding a property:
     *   {
     *     "id": "..."
     *     "type": "extension"
     *     "extensions": [
     *       {
     *         "operation": "appendTo"
     *         "target": {
     *           "id": "someObjectID"
     *         }
     *         "extension": {
     *           "propertyX": "xyz"
     *         }
     *       }
     *     ]
     *   }
     *
     * [insert]
     * Adding new object to the tree:
     *   {
     *     "id": "..."
     *     "type": "extension"
     *     "extensions": [
     *       {
     *         "operation": "insert",
     *         "target": {
     *           "id": "someObjectID",
     *           "property": "collectionOfsomeObject",
     *           "before": "somObjectIDInPropertyArray"    // (alternative "index": 0)
     *         },
     *         "extension": {
     *            "id": "newObjectID",
     *            "propertyx": "someThing",
     *            "collectiony": [...]
     *         }
     *       }
     *     ]
     *   }
     *
     * To extend the root object directly, "target.root: true" can be used instead of "target.id".
     *
     * To group inserted elements positions with its target use:
     *   "target": {
     *     "id": "someObjectID",
     *     "property": "collectionOfsomeObject",
     *     "before": "somObjectIDInPropertyArray",
     *     "groupWithTarget": true
     *   }
     * This will group the properties together. future extensions which use "before": "somObjectIDInPropertyArray"
     * will insert new elements before the grouped items. (Works the same with "after".)
     *
     * The extension property can be an object or an array of objects.
     *
     * @param extension extension to the parentModel.
     * @param parentModel object which contains id's as properties
     * @returns parentModel extended by extension
     */
    extend(extension: ExtensionModel | string | (() => ExtensionModel), parentModel: object): object;
    /**
     * Finds the index in the target array which is given through the target.
     *
     * @internal
     * @param target
     *          target information to search the index (either fixed index or a "before" or "after" tag).
     * @param targetArray
     *          array to search the extension index in.
     * @returns extension index between 0 and targetArray.length or targetArray.length if no index is found.
     */
    _findExtensionIndex(target: InsertTarget, targetArray: {
        id?: string;
        groupedWith?: string;
    }[]): number;
    /**
     * Adds the groupedWith tag to all given extensions.
     *
     * @internal
     * @param target
     *          target to bind the extensions to.
     * @param extensionsArray
     *          extensions to bind
     */
    _bindExtensionsToBeforeOrAfter(target: InsertTarget, extensionsArray: {
        groupedWith?: string;
    }[]): void;
};
export {};
//# sourceMappingURL=models.d.ts.map