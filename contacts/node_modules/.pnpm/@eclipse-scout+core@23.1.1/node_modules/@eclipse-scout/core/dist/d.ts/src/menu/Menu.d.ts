/// <reference types="jquery" />
import { Action, ActionKeyStroke, CloneOptions, EnumObject, InitModelOf, MenuDestinations, MenuEventMap, MenuModel, MenuOrder, ObjectOrChildModel, Popup, PopupAlignment, TreeVisitor, TreeVisitResult } from '../index';
export type SubMenuVisibility = EnumObject<typeof Menu.SubMenuVisibility>;
export type MenuStyle = EnumObject<typeof Menu.MenuStyle>;
export type MenuFilter = (menus: Menu[], destination: MenuDestinations) => Menu[];
export declare class Menu extends Action implements MenuModel {
    model: MenuModel;
    eventMap: MenuEventMap;
    self: Menu;
    childActions: Menu[];
    defaultMenu: boolean;
    excludedByFilter: boolean;
    menuTypes: string[];
    menuStyle: MenuStyle;
    uiCssClass: string;
    /**
     * This property is true when the menu instance was moved into an overflow-menu
     * when there's not enough space on the screen (see MenuBarLayout). When set to true, button style menus must be displayed as regular menus.
     */
    overflown: boolean;
    overflowMenu: Menu;
    /**
     * This property is set if this is a subMenu
     */
    parentMenu: Menu;
    ellipsis: boolean;
    rightAligned: boolean;
    popup: Popup;
    popupHorizontalAlignment: PopupAlignment;
    popupVerticalAlignment: PopupAlignment;
    stackable: boolean;
    separator: boolean;
    shrinkable: boolean;
    subMenuVisibility: SubMenuVisibility;
    menuFilter: MenuFilter;
    createdBy: MenuOrder;
    $submenuIcon: JQuery;
    $subMenuBody: JQuery;
    $placeHolder: JQuery;
    constructor();
    static SUBMENU_ICON: string;
    /**
     * Special styles of the menu, calculated by the MenuBar. The default value is MenuStyle.NONE.
     */
    static MenuStyle: {
        readonly NONE: 0;
        readonly DEFAULT: 1;
    };
    static SubMenuVisibility: {
        /**
         * Default: sub-menu icon is only visible when menu has text.
         */
        readonly DEFAULT: "default";
        /**
         * Text or icon: sub-menu icon is only visible when menu has text or an icon.
         */
        readonly TEXT_OR_ICON: "textOrIcon";
        /**
         * Always: sub-menu icon is always visible when menu has child-actions.
         */
        readonly ALWAYS: "always";
        /**
         * Never: sub-menu icon never visible.
         */
        readonly NEVER: "never";
    };
    protected _init(options: InitModelOf<this>): void;
    protected _initKeyStrokeContext(): void;
    protected _render(): void;
    protected _renderProperties(): void;
    protected _remove(): void;
    protected _renderSeparator(): void;
    protected _renderItem(): void;
    protected _renderActionStyle(): void;
    protected _renderSelected(): void;
    protected _closeSubMenus(): void;
    protected _removeSubMenuItems(parentMenu: Menu): void;
    protected _renderSubMenuItems(parentMenu: Menu, menus: Menu[]): void;
    /**
     * Override this method to control the toggles sub-menu behavior when this menu instance is used as parent.
     * Some menu subclasses like the ComboMenu need to show the popup menu instead.
     * @see _doActionTogglesSubMenu
     */
    protected _togglesSubMenu(): boolean;
    /** @internal */
    _doActionTogglesSubMenu(): boolean;
    protected _onMouseEvent(event: JQuery.MouseEventBase<HTMLElement, undefined, HTMLElement, HTMLElement>): void;
    /**
     * May be overridden if the criteria to open a popup differs
     */
    protected _doActionTogglesPopup(): boolean;
    protected _renderChildActions(): void;
    setSubMenuVisibility(subMenuVisibility: SubMenuVisibility): void;
    protected _renderSubMenuVisibility(): void;
    protected _renderSubMenuIcon(): void;
    protected _renderText(): void;
    protected _renderTextPosition(): void;
    protected _renderIconId(): void;
    isTabTarget(): boolean;
    recomputeEnabled(parentEnabled?: boolean): void;
    /**
     * Calculates the inherited enabled state of this menu. This is the enabled state of the next relevant parent.
     * A relevant parent is either
     * - the next parent menu with inheritAccessibility=false
     * - or the container of the menu (the parent of the root menu)
     *
     * The enabled state of the container must be used because the parent menu might be a menu which is only enabled because it has children with inheritAccessibility=false.
     * One exception: if a parent menu itself is inheritAccessibility=false. Then the container is not relevant anymore but this parent is taken instead.
     */
    protected _getInheritedAccessibility(): boolean;
    protected _findRootMenu(): Menu;
    protected _hasAccessibleChildMenu(): boolean;
    /**
     * cannot use Widget#visitChildren() here because the child actions are not always part of the children collection
     * e.g. for ellipsis menus which declare childActions as 'PreserveOnPropertyChangeProperties'. this means the childActions are not automatically added to the children list even it is a widget property!
     */
    visitChildMenus(visitor: TreeVisitor<Menu>): TreeVisitResult;
    protected _hasText(): boolean;
    protected _updateIconAndTextStyle(): void;
    /** @internal */
    _closePopup(): void;
    protected _canOpenPopup(): boolean;
    protected _openPopup(): void;
    protected _createPopup(): Popup;
    protected _createActionKeyStroke(): ActionKeyStroke;
    isToggleAction(): boolean;
    isButton(): boolean;
    /**
     * @deprecated use insertChildActions instead
     */
    addChildActions(childActions: ObjectOrChildModel<Menu> | ObjectOrChildModel<Menu>[]): void;
    insertChildAction(actionsToInsert: ObjectOrChildModel<Menu>): void;
    insertChildActions(actionsToInsert: ObjectOrChildModel<Menu> | ObjectOrChildModel<Menu>[]): void;
    deleteChildAction(actionToDelete: Menu): void;
    deleteChildActions(actionsToDelete: Menu | Menu[]): void;
    setChildActions(childActions: ObjectOrChildModel<Menu>[]): void;
    protected _setChildActions(childActions: Menu[]): void;
    protected _setInheritAccessibility(inheritAccessibility: boolean): void;
    protected _setEnabled(enabled: boolean): void;
    protected _setVisible(visible: boolean): void;
    protected _recomputeEnabledInMenuHierarchy(): void;
    setSelected(selected: boolean): void;
    protected _handleSelectedInEllipsis(): void;
    setStackable(stackable: boolean): void;
    protected _renderStackable(): void;
    setShrinkable(shrinkable: boolean): void;
    protected _renderShrinkable(): void;
    /**
     * For internal usage only.
     * Used by the MenuBarLayout when a menu is moved to the ellipsis drop down.
     * @internal
     */
    _setOverflown(overflown: boolean): void;
    protected _renderOverflown(): void;
    setMenuTypes(menuTypes: string[]): void;
    setMenuStyle(menuStyle: MenuStyle): void;
    protected _renderMenuStyle(): void;
    setDefaultMenu(defaultMenu: boolean): void;
    setMenuFilter(menuFilter: MenuFilter): void;
    clone(model: MenuModel, options: CloneOptions): this;
    focus(): boolean;
}
//# sourceMappingURL=Menu.d.ts.map