/// <reference types="jquery" />
import { BrowserFieldEventMap, BrowserFieldModel, EnumObject, FormField, IFrame, InitModelOf, PropertyChangeEvent, Rectangle } from '../../../index';
import TriggeredEvent = JQuery.TriggeredEvent;
export type BrowserFieldWindowStates = EnumObject<typeof BrowserField.WindowStates>;
export declare class BrowserField extends FormField implements BrowserFieldModel {
    model: BrowserFieldModel;
    eventMap: BrowserFieldEventMap;
    self: BrowserField;
    autoCloseExternalWindow: boolean;
    externalWindowButtonText: string;
    externalWindowFieldText: string;
    location: string;
    trackLocation: boolean;
    sandboxEnabled: boolean;
    sandboxPermissions: string;
    trustedMessageOrigins: string[];
    scrollBarEnabled: boolean;
    showInExternalWindow: boolean;
    iframe: IFrame;
    myWindow: Window;
    protected _messageListener: (event: MessageEvent) => any;
    protected _popupWindow: Window;
    protected _externalWindowTextField: JQuery;
    protected _externalWindowButton: JQuery;
    constructor();
    static WindowStates: {
        WINDOW_OPEN: string;
        WINDOW_CLOSED: string;
    };
    protected _init(model: InitModelOf<this>): void;
    protected _render(): void;
    protected _renderProperties(): void;
    protected _remove(): void;
    setLocation(location: string): void;
    protected _renderLocation(): void;
    setAutoCloseExternalWindow(autoCloseExternalWindow: boolean): void;
    setExternalWindowButtonText(externalWindowButtonText: string): void;
    protected _renderExternalWindowButtonText(): void;
    setExternalWindowFieldText(externalWindowFieldText: string): void;
    protected _renderExternalWindowFieldText(): void;
    /**
     * Note: this function is designed to deliver good results to position a popup over a BrowserField in Internet Explorer.
     * Other browsers may not perfectly position the popup, since they return different values for screenX/screenY. Also
     * there's no way to retrieve all required values from the window or screen object, that's why we have to use hard coded
     * values here. In order to make this function more flexible you could implement it as a strategy which has different
     * browser dependent implementations.
     *
     * This implementation does also deal with a multi screen setup (secondary monitor). An earlier implementation used
     * screen.availWidth to make sure the popup is within the visible area of the screen. However, screen.availWidth only
     * returns the size of the primary monitor, so we cannot use it. There's no way to check for a secondary monitor from
     * a HTML document. So we removed the check entirely, which shouldn't be an issue since the browser itself does prevent
     * popups from having an invalid position.
     */
    protected _calcPopupBounds(): Rectangle;
    protected _openPopupWindow(reopenIfClosed?: boolean): void;
    protected _popupWindowOpen(popup: Window): void;
    protected _onMessage(event: MessageEvent): void;
    protected _isValidMessageSource(source: MessageEventSource): boolean;
    /**
     * Sends a message to the embedded web page (`iframe`).
     *
     * @param message
     *          The message to send.
     * @param targetOrigin
     *          The expected origin of the receiving `window`. If the origin does not match, the browser will not
     *          dispatch the message for security reasons. See the
     *          <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">documentation</a> for
     *          details.
     * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">window.postMessage (MDN)</a>
     */
    postMessage(message: any, targetOrigin: string): void;
    /** @see BrowserFieldModel.sandboxPermissions */
    setTrackLocation(trackLocation: boolean): void;
    protected _onIFramePropertyChange(event: PropertyChangeEvent<IFrame>): void;
    protected _onLoad(event: TriggeredEvent): void;
    /** @see BrowserFieldModel.sandboxEnabled */
    setSandboxEnabled(sandboxEnabled: boolean): void;
    /** @see BrowserFieldModel.sandboxPermissions */
    setSandboxPermissions(sandboxPermissions: string): void;
    setScrollBarEnabled(scrollBarEnabled: boolean): void;
}
//# sourceMappingURL=BrowserField.d.ts.map