/// <reference types="jquery" />
import { AbstractLayout, Cell, CellEditorPopupModel, Column, EventHandler, InitModelOf, KeyStroke, KeyStrokeManagerKeyStrokeEvent, Popup, Rectangle, SomeRequired, Table, TableRow, TableRowOrderChangedEvent, ValueField } from '../../index';
export declare class CellEditorPopup<TValue> extends Popup implements CellEditorPopupModel<TValue> {
    model: CellEditorPopupModel<TValue>;
    initModel: SomeRequired<this['model'], 'parent' | 'column' | 'cell'>;
    table: Table;
    column: Column<TValue>;
    row: TableRow;
    cell: Cell<TValue>;
    protected _rowOrderChangedFunc: EventHandler<TableRowOrderChangedEvent>;
    protected _pendingCompleteCellEdit: JQuery.Promise<void>;
    protected _keyStrokeHandler: EventHandler<KeyStrokeManagerKeyStrokeEvent>;
    constructor();
    protected _init(options: InitModelOf<this>): void;
    protected _createLayout(): AbstractLayout;
    protected _initKeyStrokeContext(): void;
    protected _createCloseKeyStroke(): KeyStroke;
    protected _open($parent: JQuery): void;
    protected _getDefaultOpen$Parent(): JQuery;
    protected _render(): void;
    /**
     * Selection border is an after element that is moved to top a little to cover the border of the previous row.
     * This won't happen for the first row if there is no table header, since there is no space on top to move it up.
     * In that case the selection is moved down by 1px to ensure the height of the selection always stays the same.
     * If there is no border between the rows, there is no adjustment necessary, the selection is as height as the row.
     * -> Position and size of the cell editor popup depends on the selection of the current row and the table style (with or without row borders)
     */
    protected _alignWithSelection(): void;
    /** @internal */
    _rowSelectionBounds(): Rectangle;
    protected _postRender(): void;
    protected _remove(): void;
    position(switchIfNecessary?: boolean): void;
    /**
     * @param waitForAcceptInput default is true
     * @returns A promise resolved when acceptInput is performed on the editor field
     */
    completeEdit(waitForAcceptInput?: boolean): JQuery.Promise<any>;
    isCompleteCellEditRequested(): boolean;
    cancelEdit(): void;
    protected _onMouseDownOutside(event: MouseEvent): void;
    protected _propagateMouseDownToTableRow(event: MouseEvent): void;
    protected _onKeyStroke(event: KeyStrokeManagerKeyStrokeEvent): void;
    protected _invokeCompleteEditBeforeKeyStroke(event: KeyStrokeManagerKeyStrokeEvent): boolean;
    waitForCompleteCellEdit(): JQuery.Promise<void>;
}
export type CellEditorRenderedOptions<TValue> = {
    openFieldPopup: boolean;
    cellEditorPopup: CellEditorPopup<TValue>;
};
export interface ValueFieldWithCellEditorRenderedCallback<TValue extends TModelValue, TModelValue = TValue> extends ValueField<TValue, TModelValue> {
    onCellEditorRendered(options: CellEditorRenderedOptions<TValue>): void;
}
//# sourceMappingURL=CellEditorPopup.d.ts.map