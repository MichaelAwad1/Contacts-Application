/// <reference types="jquery" />
import { DisabledStyle, DisplayParent, DisplayViewId, EnumObject, Event, FileChooser, FileChooserController, FormController, FormEventMap, FormLifecycle, FormModel, FormRevealInvalidFieldEvent, GlassPaneRenderer, GroupBox, InitModelOf, KeyStroke, KeyStrokeContext, MessageBox, MessageBoxController, ObjectOrChildModel, Point, PopupWindow, Rectangle, Status, StatusOrModel, TreeVisitResult, ValidationResult, Widget } from '../index';
export type DisplayHint = EnumObject<typeof Form.DisplayHint>;
export declare class Form extends Widget implements FormModel, DisplayParent {
    model: FormModel;
    eventMap: FormEventMap;
    self: Form;
    animateOpening: boolean;
    askIfNeedSave: boolean;
    askIfNeedSaveText: string;
    data: any;
    displayViewId: DisplayViewId;
    displayHint: DisplayHint;
    maximized: boolean;
    headerVisible: boolean;
    modal: boolean;
    displayParent: DisplayParent;
    dialogs: Form[];
    views: Form[];
    messageBoxes: MessageBox[];
    fileChoosers: FileChooser[];
    focusedElement: Widget;
    closable: boolean;
    cacheBounds: boolean;
    cacheBoundsKey: string;
    resizable: boolean;
    movable: boolean;
    rootGroupBox: GroupBox;
    saveNeeded: boolean;
    saveNeededVisible: boolean;
    formController: FormController;
    messageBoxController: MessageBoxController;
    fileChooserController: FileChooserController;
    closeKeyStroke: KeyStroke;
    showOnOpen: boolean;
    initialFocus: Widget;
    renderInitialFocusEnabled: boolean;
    /** set by PopupWindow if this Form has displayHint=Form.DisplayHint.POPUP_WINDOW */
    popupWindow: PopupWindow;
    title: string;
    subTitle: string;
    iconId: string;
    status: Status;
    uiCssClass: string;
    lifecycle: FormLifecycle;
    detailForm: boolean;
    $statusIcons: JQuery[];
    $header: JQuery;
    $statusContainer: JQuery;
    $close: JQuery;
    $saveNeeded: JQuery;
    $icon: JQuery;
    $title: JQuery;
    $subTitle: JQuery;
    $dragHandle: JQuery;
    protected _glassPaneRenderer: GlassPaneRenderer;
    protected _preMaximizedBounds: Rectangle;
    protected _resizeHandler: (Event: any) => boolean;
    protected _windowResizeHandler: () => void;
    constructor();
    static DisplayHint: {
        readonly DIALOG: "dialog";
        readonly POPUP_WINDOW: "popupWindow";
        readonly VIEW: "view";
    };
    protected _init(model: InitModelOf<this>): void;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _render(): void;
    protected _renderProperties(): void;
    protected _postRender(): void;
    protected _destroy(): void;
    protected _remove(): void;
    protected _renderForm(): void;
    /** @see FormModel.modal */
    setModal(modal: boolean): void;
    protected _renderModal(): void;
    protected _installLifecycle(): void;
    protected _createLifecycle(): FormLifecycle;
    /**
     * Loads the data and renders the form afterwards by adding it to the desktop.
     * <p>
     * Calling this method is equivalent to calling load() first and once the promise is resolved, calling show().
     * <p>
     * Keep in mind that the form won't be rendered immediately after calling {@link open}. Because promises are always resolved asynchronously,
     * {@link show} will be called delayed even if {@link load} does nothing but return a resolved promise.<br>
     * This is only relevant if you need to access properties which are only available when the form is rendered (e.g. $container), which is not recommended anyway.
     * <p>
     */
    open(): JQuery.Promise<void>;
    /**
     * Initializes the life cycle and calls the {@link _load} function.
     * @returns promise which is resolved when the form is loaded.
     */
    load(): JQuery.Promise<void>;
    /**
     * @returns promise which is resolved when the form is loaded, respectively when the 'load' event is triggered.
     */
    whenLoad(): JQuery.Promise<Event<Form>>;
    /**
     * Lifecycle handle function registered for 'load'.
     */
    protected _onLifecycleLoad(): JQuery.Promise<Status>;
    /**
     * This function is called when an error occurs while the {@link _load} function is called or when the {@link _load} function returns with a rejected promise.
     * By default, the Form is destroyed and the error re-thrown so a caller of {@link Form.load()} may catch the error.
     *
     */
    protected _handleLoadError(error: Error): JQuery.Promise<Status>;
    /**
     * Method may be implemented to load the data.
     * By default, a resolved promise containing the provided {@link this.data} is returned.
     */
    protected _load(): JQuery.Promise<object>;
    /**
     * @returns promise which is resolved when the form is post loaded, respectively when the 'postLoad' event is triggered.
     */
    whenPostLoad(): JQuery.Promise<Event<Form>>;
    protected _onLifecyclePostLoad(): JQuery.Promise<void>;
    protected _postLoad(): JQuery.Promise<void>;
    /** @see FormModel.data */
    setData(data: any): void;
    importData(): void;
    exportData(): any;
    /**
     * Saves and closes the form.
     * @returns promise which is resolved when the form is closed.
     */
    ok(): JQuery.Promise<void>;
    /**
     * Saves the changes without closing the form.
     * @returns promise which is resolved when the form is saved
     *    Note: it will be resolved even if the form does not require save and therefore even if {@link @_save} is not called.
     *    If you only want to be informed when save is required and {@link @_save} executed then you could use {@link whenSave()} or {@link on('save')} instead.
     */
    save(): JQuery.Promise<void>;
    /**
     * @returns promise which is resolved when the form is saved, respectively when the 'save' event is triggered.
     */
    whenSave(): JQuery.Promise<Event<Form>>;
    protected _onLifecycleSave(): JQuery.Promise<Status>;
    /**
     * This function is called by the lifecycle, for instance when the 'ok' function is called.
     * The function is called every time the 'ok' function is called, which means it runs even when
     * there is not a single touched field. The function should be used to implement an overall validate
     * logic which is not related to a specific field. For instance, you could validate the state of an
     * internal member variable.
     * <p>
     * You should return a Status object with severity ERROR in case the validation fails.
     * @internal
     */
    _validate(): Status;
    /**
     * This function is called by the lifecycle, when {@link save} is called.
     *
     * The data given to this function is the result of {@link exportData} which was called in advance.
     *
     * @returns a promise which may contain a {@link Status} specifying if the save operation was successful. The promise may be empty which means the save operation was successful.
     */
    protected _save(data: object): JQuery.Promise<Status>;
    /**
     * Resets the form to its initial state.
     */
    reset(): JQuery.Promise<void>;
    /**
     * @returns promise which is resolved when the form is reset, respectively when the 'reset' event is triggered.
     */
    whenReset(): JQuery.Promise<Event<Form>>;
    protected _onLifecycleReset(): void;
    /**
     * Closes the form if there are no changes made. Otherwise, it shows a message box asking to save the changes.
     */
    cancel(): JQuery.Promise<void>;
    /**
     * Closes the form and discards any unsaved changes.
     */
    close(): JQuery.Promise<void>;
    /**
     * @returns promise which is resolved when the form is closed, respectively when the 'close' event is triggered.
     */
    whenClose(): JQuery.Promise<Event<Form>>;
    /**
     * Destroys the form and removes it from the desktop.
     */
    protected _onLifecycleClose(): void;
    protected _close(): void;
    /**
     * This function is called when the user presses the "x" icon.<p>
     * It will either call {@link #close()} or {@link #cancel()), depending on the enabled and visible system buttons, see {@link _abort}.
     */
    abort(): void;
    /**
     * @returns promise which is resolved when the form is aborted, respectively when the 'abort' event is triggered.
     */
    whenAbort(): JQuery.Promise<Event<Form>>;
    /**
     * Will call {@link #close()} if there is a close menu or button, otherwise {@link #cancel()) will be called.
     */
    protected _abort(): void;
    /** @internal */
    _afterAbort(): void;
    revealInvalidField(validationResult: ValidationResult): void;
    protected _revealInvalidField(validationResult: ValidationResult): void;
    protected _createRevealInvalidFieldEvent(validationResult: ValidationResult): FormRevealInvalidFieldEvent;
    /**
     * Override this method to provide a keystroke which closes the form.
     * The default implementation returns an AbortKeyStroke which handles the ESC key and calls {@link abort}.
     * <p>
     * The key stroke is only active if {@link this.closable} is set to true.
     */
    protected _createCloseKeyStroke(): KeyStroke;
    protected _setClosable(closable: boolean): void;
    /** @see FormModel.closable */
    setClosable(closable: boolean): void;
    protected _renderClosable(): void;
    protected _onCloseIconClick(): void;
    /** @see FormModel.resizable */
    setResizable(resizable: boolean): void;
    protected _renderResizable(): void;
    protected _onResize(event: Event): boolean;
    /** @see FormModel.movable */
    setMovable(movable: boolean): void;
    protected _renderMovable(): void;
    protected _onDialogMouseDown(): void;
    activate(): void;
    show(): void;
    hide(): void;
    /**
     * Checks whether the form is shown, which means whether a form has been added to the form stack of the display parent, e.g. by using {@link showForm}.<br>
     * It does not necessarily mean the user can see the content of the form for sure,
     * e.g. if the form is opened as a view the tab may be inactive because another view is active, or in case of a dialog it may be hidden behind another dialog or shown in an inactive view.
     */
    isShown(): boolean;
    protected _renderHeader(): void;
    protected _removeHeader(): void;
    /** @see FormModel.rootGroupBox */
    setRootGroupBox(rootGroupBox: ObjectOrChildModel<GroupBox>): void;
    protected _setRootGroupBox(rootGroupBox: GroupBox): void;
    protected _renderSaveNeeded(): void;
    /** @see FormModel.askIfNeedSave */
    setAskIfNeedSave(askIfNeedSave: boolean): void;
    /** @see FormModel.displayViewId */
    setDisplayViewId(displayViewId: DisplayViewId): void;
    /** @see FormModel.displayHint */
    setDisplayHint(displayHint: DisplayHint): void;
    /** @see FormModel.saveNeededVisible */
    setSaveNeededVisible(visible: boolean): void;
    protected _renderSaveNeededVisible(): void;
    protected _renderCssClass(cssClass?: string, oldCssClass?: string): void;
    /** @see FormModel.status */
    setStatus(status: StatusOrModel): void;
    protected _setStatus(status: StatusOrModel): void;
    protected _renderStatus(): void;
    protected _renderSingleStatus(status: Status, $prevIcon: JQuery): JQuery;
    /** @see FormModel.showOnOpen */
    setShowOnOpen(showOnOpen: boolean): void;
    protected _updateTitleForDom(): void;
    isDialog(): boolean;
    isPopupWindow(): boolean;
    isView(): boolean;
    protected _onMove(newOffset: {
        top: number;
        left: number;
    }): void;
    moveTo(position: Point): void;
    position(): void;
    updateCacheBounds(): void;
    appendTo($parent: JQuery): void;
    /** @see FormModel.headerVisible */
    setHeaderVisible(headerVisible: boolean): void;
    protected _renderHeaderVisible(): void;
    /** @see FormModel.title */
    setTitle(title: string): void;
    protected _renderTitle(): void;
    /** @see FormModel.subTitle */
    setSubTitle(subTitle: string): void;
    protected _renderSubTitle(): void;
    /** @see FormModel.iconId */
    setIconId(iconId: string): void;
    protected _renderIconId(): void;
    protected _setViews(views: Form[]): void;
    setDisabledStyle(disabledStyle: DisabledStyle): void;
    /** @see FormModel.displayParent */
    setDisplayParent(displayParent: DisplayParent): void;
    protected _setDisplayParent(displayParent: DisplayParent): void;
    /** @see FormModel.maximized */
    setMaximized(maximized: boolean): void;
    protected _renderMaximized(): void;
    protected _onWindowResize(): void;
    protected _maximize(): void;
    prefBounds(): Rectangle;
    protected _attach(): void;
    /**
     * Method invoked when:
     *  - this is a 'detailForm' and the outline content is displayed;
     *  - this is a 'view' and the view tab is selected;
     *  - this is a child 'dialog' or 'view' and its 'displayParent' is attached;
     */
    protected _postAttach(): void;
    /**
     * Method invoked when:
     *  - this is a 'detailForm' and the outline content is hidden;
     *  - this is a 'view' and the view tab is deselected;
     *  - this is a child 'dialog' or 'view' and its 'displayParent' is detached;
     */
    protected _detach(): void;
    renderInitialFocus(): void;
    /**
     * This method returns the HtmlElement (DOM node) which is used by FocusManager/FocusContext/Popup
     * to focus the initial element. The impl. of these classes relies on HtmlElements, so we can not
     * easily use the focus() method of FormField here. Furthermore, some classes like Button
     * are sometimes 'adapted' by a ButtonAdapterMenu, which means the Button itself is not rendered, but
     * we must know the $container of the adapter menu to focus the correct element. That's why we call
     * the getFocusableElement() method.
     */
    protected _initialFocusElement(): any;
    protected _installFocusContext(): void;
    protected _uninstallFocusContext(): void;
    touch(): void;
    /**
     * Function required for objects that act as 'displayParent'.
     *
     * @returns 'true' if this Form is currently accessible to the user
     */
    inFront(): boolean;
    /**
     * Visits all form-fields of this form in pre-order (top-down).
     */
    visitFields(visitor: (FormField: any) => TreeVisitResult | void): void;
    /**
     * Visits all dialogs, messageBoxes and fileChoosers of this form in pre-order (top-down).
     * filter is an optional parameter.
     */
    visitDisplayChildren(visitor: (child: Form | MessageBox | FileChooser) => void, filter?: (child: Form | MessageBox | FileChooser) => boolean): void;
    storeCacheBounds(bounds: Rectangle): void;
    readCacheBounds(): Rectangle;
    /**
     * @returns the form the widget belongs to (returns the first parent which is a {@link Form}).
     */
    static findForm(widget: Widget): Form;
    /**
     * @returns the first form which is not an inner form of a wrapped form field
     */
    static findNonWrappedForm(widget: Widget): Form;
}
//# sourceMappingURL=Form.d.ts.map