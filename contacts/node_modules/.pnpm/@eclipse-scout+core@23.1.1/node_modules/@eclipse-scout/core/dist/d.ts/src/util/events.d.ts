/// <reference types="jquery" />
import { Predicate } from '../index';
declare function isTouchEvent(event: JQuery.Event): event is JQuery.TouchEventBase;
export declare const events: {
    /**
     * @returns the x coordinate where the event happened, works for touch events as well.
     */
    pageX(event: JQuery.TriggeredEvent): number;
    /**
     * @returns the y coordinate where the event happened, works for touch events as well.
     */
    pageY(event: JQuery.TriggeredEvent): number;
    touchdown(touch: boolean, suffix?: string): string;
    touchmove(touch: boolean, suffix?: string): string;
    touchendcancel(touch: boolean, suffix?: string): string;
    touchOrMouse(touch: boolean, touchEvent: string, mouseEvent: string, suffix?: string): string;
    isTouchEvent: typeof isTouchEvent;
    fixTouchEvent(event: JQuery.Event): void;
    /**
     * @returns an object containing passive: true if the browser supports passive event listeners, otherwise returns false.
     */
    passiveOptions(): boolean | {
        passive: boolean;
    };
    /**
     * Listens for scroll events and executes startHandler on first event. It then regularly checks for further scroll events and executes endHandler if no event has fired since a certain amount of time and the user has released his finger.
     * If he does not release his finger the endHandler won't be called even if the pane has stopped scrolling.
     */
    onScrollStartEndDuringTouch($elem: JQuery, startHandler: () => void, endHandler: () => void): void;
    /**
     * Forwards the event to the given target by creating a new event with the same data as the old one.
     * Prevents default action of the original event if preventDefault was called for the forwarded event.
     * Does not use jQuery to make sure the capture phase is executed as well.
     *
     * <p>
     * <b>Important</b>
     * This function only works in browsers supporting the Event constructor (e.g. KeyboardEvent: https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/KeyboardEvent).
     * </p>
     *
     * @param target the element which should receive the event
     * @param event the original event which should be propagated
     */
    propagateEvent(target: EventTarget, event: Event): void;
    /**
     * Adds an event listener for each given type to the source which propagates the events for that type to the target.
     *
     * <p>
     * <b>Important</b>
     * This function only works in browsers supporting the Event constructor (e.g. KeyboardEvent: https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/KeyboardEvent).
     * </p>
     *
     * @param source the element for which the event listener should be added.
     * @param target the element which should receive the event.
     * @param types an array of event types.
     * @param an optional filter function which can return false if the event should not be propagated.
     */
    addPropagationListener(source: EventTarget, target: EventTarget, types: string[], filter?: Predicate<Event>): void;
    /**
     * Adds swipe event listeners to the element given.
     *
     * @param $element The element on which the listeners should be attached.
     * @param id An event listener id used to be registered on the window object.
     * @param [onDown] Callback to be invoked when the swipe is started (mouse or touch down).
     * @param [onMove] Callback to be invoked when mouse (or finger if touch) is moved (while being down).
     * @param [onUp] Callback to be invoked when the swipe is ended (mouse or finger released).
     */
    onSwipe($element: JQuery, id: string, onDown?: (event: SwipeCallbackEvent) => boolean, onMove?: (event: SwipeCallbackEvent) => number, onUp?: (event: SwipeCallbackEvent) => void): void;
};
export interface SwipeCallbackEvent {
    /**
     * The original event received from the browser.
     */
    originalEvent: JQuery.TriggeredEvent;
    /**
     * The left position of the element at the moment the swipe was started.
     */
    originalLeft: number;
    /**
     * The horizontal delta the swipe has already moved (negative values mean to the left of the original left position).
     */
    deltaX: number;
    /**
     * The current left position of the element.
     */
    newLeft: number;
    /**
     * -1 if the move is to the left, 1 if the move is to the right, 0 or -0 if it is not moved yet
     */
    direction: number;
}
export {};
//# sourceMappingURL=events.d.ts.map