/// <reference types="jquery" />
import { AggregateTableRow, Column, Table, TableRow } from '../../index';
export declare class ColumnOptimalWidthMeasurer {
    column: Column<any>;
    table: Table;
    deferred: JQuery.Deferred<number>;
    imageCount: number;
    completeImageCount: number;
    $measurement: JQuery;
    protected _imageLoadOrErrorHandler: (Event: any) => void;
    protected _columnCellContents: Record<string, boolean>;
    constructor(column: Column<any>);
    measure(): number | JQuery.Promise<number>;
    remove(): void;
    protected _measure(): number;
    protected _resolve(optimalWidth: number): void;
    protected _appendElements(): void;
    protected _appendHeader(): void;
    protected _appendRows(): void;
    protected _appendRow(row: TableRow): void;
    protected _appendAggregateRows(): void;
    protected _appendAggregateRow(row: AggregateTableRow): void;
    /**
     * For aggregate rows the text of neighbour cells may overlap into the own cell.
     * To ensure there is enough space for the content of this cell, the overlap of the neighbour must be included.
     * To have access to neighbour cells and to measure its sizes the whole aggregate row must be constructed.
     *
     * @returns The created cell
     */
    protected _build$CellForAggregateRow(row: AggregateTableRow): JQuery;
    /**
     * Compute how much the neighbour cell overlaps into the given cell.
     * @param $cell The cell for which the overlap should be computed
     * @returns The overlap in pixels.
     */
    protected _getAggregateOverlap($cell: JQuery): number;
    protected _appendToMeasurement($calc: JQuery): void;
    protected _onImageLoadOrError(event: Event): void;
}
//# sourceMappingURL=ColumnOptimalWidthMeasurer.d.ts.map