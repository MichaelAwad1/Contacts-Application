/// <reference types="jquery" />
import { AddCellEditorFieldCssClassesOptions, CellEditorPopup, CellEditorRenderedOptions, DateFieldEventMap, DateFieldModel, DateFormat, DateFormatAnalyzeInfo, DatePicker, DatePickerDateSelectEvent, Event, HtmlComponent, InitModelOf, KeyStrokeContext, Popup, Predicate, Status, StatusType, TimePicker, TimePickerTimeSelectEvent, ValueField, ValueFieldWithCellEditorRenderedCallback } from '../../../index';
export declare class DateField extends ValueField<Date, Date | string> implements DateFieldModel, ValueFieldWithCellEditorRenderedCallback<Date, Date | string> {
    model: DateFieldModel;
    eventMap: DateFieldEventMap;
    self: DateField;
    popup: Popup & {
        getDatePicker?(): DatePicker;
        getTimePicker?(): TimePicker;
    };
    autoDate: Date;
    dateDisplayText: string;
    dateHasText: boolean;
    dateFocused: boolean;
    dateFormatPattern: string;
    hasDate: boolean;
    touchMode: boolean;
    embedded: boolean;
    hasTime: boolean;
    hasTimePopup: boolean;
    timeDisplayText: string;
    timeHasText: boolean;
    timePickerResolution: number;
    timeFormatPattern: string;
    timeFocused: boolean;
    isolatedDateFormat: DateFormat;
    isolatedTimeFormat: DateFormat;
    allowedDates: Date[];
    htmlDateTimeComposite: HtmlComponent;
    $dateField: JQuery;
    $timeField: JQuery;
    $dateFieldIcon: JQuery;
    $timeFieldIcon: JQuery;
    $dateClearIcon: JQuery;
    $timeClearIcon: JQuery;
    /** @internal */
    _$predictDateField: JQuery;
    /** @internal */
    _$predictTimeField: JQuery;
    /**
     * This is the storage for the time (as date) while the focus in the field (e.g. when pressing up/down). In date fields, the date picker is used for that purposes.
     */
    protected _tempTimeDate: Date;
    protected _cellEditorPopup: CellEditorPopup<Date>;
    constructor();
    static ErrorCode: {
        PARSE_ERROR: number;
    };
    /**
     * Predicate function to find a PARSE_ERROR.
     */
    static PARSE_ERROR_PREDICATE: Predicate<Status>;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _init(model: InitModelOf<this>): void;
    /**
     * Initializes the date format before calling set value.
     * This cannot be done in _init because the value field would call _setValue first
     */
    protected _initValue(value: Date): void;
    createDatePopup(): Popup;
    createTimePopup(): Popup;
    protected _render(): void;
    protected _renderProperties(): void;
    protected _remove(): void;
    setHasDate(hasDate: boolean): void;
    protected _setHasDate(hasDate: boolean): void;
    protected _renderHasDate(): void;
    setHasTime(hasTime: boolean): void;
    protected _setHasTime(hasTime: boolean): void;
    protected _renderHasTime(): void;
    setTimePickerResolution(timePickerResolution: number): void;
    protected _setTimePickerResolution(timePickerResolution: number): void;
    protected _renderPlaceholder($field?: JQuery): void;
    protected _removePlaceholder($field?: JQuery): void;
    protected _fieldForPlaceholder(): JQuery;
    setDateFormatPattern(dateFormatPattern: string): void;
    protected _setDateFormatPattern(dateFormatPattern: string): void;
    setTimeFormatPattern(timeFormatPattern: string): void;
    protected _setTimeFormatPattern(timeFormatPattern: string): void;
    protected _renderEnabled(): void;
    protected _renderDisplayText(): void;
    protected _readDisplayText(): string;
    protected _renderDateDisplayText(): void;
    protected _readDateDisplayText(): string;
    protected _renderTimeDisplayText(): void;
    protected _readTimeDisplayText(): string;
    setDisplayText(displayText: string): void;
    protected _setDisplayText(displayText: string): void;
    protected _ensureValue(value: Date | string): Date;
    protected _validateValue(value: Date): Date;
    isDateAllowed(date: Date): boolean;
    protected _valueEquals(valueA: Date, valueB: Date): boolean;
    setAutoDate(autoDate: Date | string): void;
    protected _setAutoDate(autoDate: Date | string): void;
    setAllowedDates(allowedDates: (string | Date)[]): void;
    protected _setAllowedDates(allowedDates: (string | Date)[]): void;
    /** @internal */
    _renderErrorStatus(): void;
    protected _errorStatusClass(): string;
    protected _renderFont(): void;
    protected _renderForegroundColor(): void;
    protected _renderBackgroundColor(): void;
    activate(): void;
    getFocusableElement(): JQuery;
    protected _onDateFieldMouseDown(): void;
    protected _onTimeFieldMouseDown(): void;
    setDateFocused(dateFocused: boolean): void;
    protected _renderDateFocused(): void;
    protected _updateTimeHasText(): void;
    setTimeHasText(timeHasText: boolean): void;
    protected _renderTimeHasText(): void;
    protected _updateDateHasText(): void;
    setDateHasText(dateHasText: boolean): void;
    protected _renderDateHasText(): void;
    clear(): void;
    protected _clear(): void;
    protected _onDateClearIconMouseDown(event: JQuery.MouseDownEvent): void;
    protected _onDateIconMouseDown(event: JQuery.MouseDownEvent): void;
    setTimeFocused(timeFocused: boolean): void;
    protected _renderTimeFocused(): void;
    protected _renderClearable(): void;
    protected _renderDateClearable(): void;
    protected _renderTimeClearable(): void;
    protected _onTimeClearIconMouseDown(event: JQuery.MouseDownEvent): void;
    protected _onTimeIconMouseDown(event: JQuery.MouseDownEvent): void;
    protected _onDateFieldBlur(event: JQuery.BlurEvent): void;
    protected _onDateFieldFocus(event: JQuery.FocusEvent): void;
    protected _onTimeFieldBlur(event: JQuery.BlurEvent): void;
    protected _onTimeFieldFocus(): void;
    /**
     * Handle "navigation" keys, i.e. keys that don't emit visible characters. Character input is handled
     * in _onDateFieldInput(), which is fired after 'keydown'.
     */
    protected _onDateFieldKeyDown(event: JQuery.KeyDownEvent): void;
    /**
     * Handle changed input. This method is fired when the field's content has been altered by a user
     * action (not by JS) such as pressing a character key, deleting a character using DELETE or
     * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag-and-drop.
     * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled
     * in _onDateFieldKeyDown().
     */
    protected _onDateFieldInput(event: JQuery.TriggeredEvent): void;
    acceptInput(whileTyping?: boolean): void;
    /**
     * Clears the time field if date field is empty before accepting the input.<br/>
     * Don't delete invalid input from the time field.
     */
    acceptDate(): void;
    /**
     * Clears the date field if time field is empty before accepting the input.<br/>
     * Don't delete invalid input from the time field.
     */
    acceptTime(): void;
    acceptDateTime(acceptDate: boolean, acceptTime: boolean): void;
    /**
     * Handle "navigation" keys, i.e. keys that don't emit visible characters. Character input is handled
     * in _onTimeFieldInput(), which is fired after 'keydown'.
     */
    protected _onTimeFieldKeyDown(event: JQuery.KeyDownEvent): void;
    /**
     * Handle changed input. This method is fired when the field's content has been altered by a user
     * action (not by JS) such as pressing a character key, deleting a character using DELETE or
     * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag-and-drop.
     * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled
     * in _onTimeFieldKeyDown().
     */
    protected _onTimeFieldInput(event: JQuery.TriggeredEvent): void;
    protected _onDatePickerDateSelect(event: DatePickerDateSelectEvent): void;
    protected _onTimePickerTimeSelect(event: TimePickerTimeSelectEvent): void;
    protected _setNewDateTimeValue(newValue: Date): void;
    protected _createPredictionField($inputField: JQuery): JQuery;
    protected _removePredictionFields(): void;
    protected _setDateDisplayText(displayText: string): void;
    protected _setTimeDisplayText(displayText: string): void;
    protected _computeDisplayText(dateDisplayText: string, timeDisplayText: string): string;
    protected _splitDisplayText(displayText: string): {
        dateText: string;
        timeText: string;
    };
    protected _updateDisplayTextProperty(): void;
    aboutToBlurByMouseDown(target: Element): void;
    /**
     * Returns null if both arguments are not set. Otherwise, this.value or the current date
     * is used as basis and the given arguments are applied to that date. The result is returned.
     */
    protected _newTimestampAsDate(date: Date, time: Date): Date;
    /**
     * Returns the reference date for this date field, which is used in various places (i.e. opening the date picker, analyzing user inputs).
     *
     * The reference date is either (in that order):
     * - the model's "auto timestamp" (as date), or
     * - the current date/time
     */
    protected _referenceDate(): Date;
    /**
     * Find nearest allowed date which is equals or greater than the current referenceDate.
     */
    protected _findAllowedReferenceDate(referenceDate: Date): Date;
    openDatePopup(): void;
    closePopup(): void;
    toggleDatePopup(): void;
    openTimePopup(): void;
    toggleTimePopup(): void;
    protected _parseValue(displayText: string): Date;
    /**
     * Don't add error if it is a DatePredictionFailedStatus because the predict function has already added a parsing error.
     */
    protected _addParsingFailedErrorStatus(displayText: string, error: any): void;
    /**
     * @returns null if input is invalid, otherwise a DateFieldPredictionResult
     */
    protected _predictDate(inputText: string): DateFieldPredictionResult;
    /**
     * @returns null if input is invalid, otherwise a DateFieldPredictionResult
     */
    protected _predictTime(inputText: string): DateFieldPredictionResult;
    protected _analyzeInputAsDate(inputText: string, startDate: Date): DateFormatAnalyzeInfo;
    protected _analyzeInputAsTime(inputText: string, startDate: Date): DateFormatAnalyzeInfo;
    /**
     * This method updates the parts (date, time) of the error status.
     */
    protected _setErrorStatusPart(property: string, valid: boolean): void;
    protected _removePredictErrorStatus(): void;
    protected _createInvalidValueStatus(statusType: StatusType, value: any, error: any): Status;
    protected _setDateValid(valid: boolean): void;
    protected _setTimeValid(valid: boolean): void;
    protected _isErrorStatusPartValid(property: string): boolean;
    protected _isDateValid(): boolean;
    protected _isTimeValid(): boolean;
    /**
     * Method invoked if being rendered within a cell-editor (mode= {@link FormField.Mode.CELLEDITOR}), and once the editor finished its rendering.
     */
    onCellEditorRendered(options: CellEditorRenderedOptions<Date>): void;
    protected _onPopupDestroy(event: Event<Popup>): void;
    prepareForCellEdit(opts: AddCellEditorFieldCssClassesOptions): void;
    /**
     * @returns DatePicker instance from popup, because the property name is different for DatePickerPopup and DatePickerTouchPopup.
     */
    getDatePicker(): DatePicker;
    /**
     * Opens picker and selects date
     *
     * @param date
     *          optional, Date to pass to the date picker. If no date is specified, the reference date
     *          is preselected (not selected!).
     */
    openDatePopupAndSelect(date: Date): void;
    preselectDate(date: Date, animated: boolean): void;
    selectDate(date: Date, animated: boolean): void;
    /**
     * @returns TimePicker instance from popup, because the property name is different for TimePickerPopup and TimePickerTouchPopup.
     */
    getTimePicker(): TimePicker;
    /**
     * Opens picker and selects date
     *
     * @param date
     *          optional, Date to pass to the date picker. If no date is specified, the reference date
     *          is preselected (not selected!).
     */
    openTimePopupAndSelect(time: Date): void;
    preselectTime(time: Date): void;
    selectTime(time: Date): void;
    shiftSelectedDate(years: number, months: number, days: number): void;
    shiftSelectedTime(hourUnits: number, minuteUnits: number, secondUnits: number): void;
    protected _formatValue(value: Date): string | JQuery.Promise<string>;
    protected _renderFieldStyle(): void;
    protected _renderDisabledStyle(): void;
    /** @internal */
    _triggerAcceptInput(whileTyping?: boolean): void;
}
export type DateFieldPredictionResult = {
    date: Date;
    text: string;
};
//# sourceMappingURL=DateField.d.ts.map