import { Cell, ChildModelOf, Column, ColumnModel, Filter, InitModelOf, MenuModel, ModelAdapter, ObjectOrChildModel, ObjectOrModel, ObjectType, Primitive, RemoteEvent, Session, Table, TableModel, TableRow, TableRowModel, TableTextUserFilter, TextColumnUserFilter, Widget } from '../../index';
import { MenuSpecHelper, SpecTable, SpecTableAdapter } from '../index';
export declare class TableSpecHelper {
    session: Session;
    menuHelper: MenuSpecHelper;
    constructor(session: Session);
    createModel(columns: ObjectOrChildModel<Column<any>>[], rows: ObjectOrModel<TableRow>[]): TableModelWithCells;
    createModelRow(id?: string, cells?: (Primitive | object | Cell)[], parentRow?: TableRow | string): TableRowModel;
    /**
     *
     * @param texts array of texts for the cells in the new row or a string if only one cell should be created.
     * @param withoutCells true if only text instead of cells should be created (server only sends text without a cell object if no other properties are set)
     */
    createModelRowByTexts(id: string, texts: string[] | string, withoutCells?: boolean): TableRowModel;
    /**
     *
     * @param values array of values for the cells in the new row or a number if only one cell should be created.
     */
    createModelRowByValues(id: string, values: any | any[]): TableRowModel;
    createModelColumn<T>(text: string, type?: ObjectType<Column<T>>): ChildModelOf<Column<T>> & {
        uiSortPossible: boolean;
    };
    createModelCell(text?: string, value?: any): Cell;
    createMenuModel(text?: string, icon?: string): MenuModel;
    createMenuModelWithSingleAndHeader(text: string, icon?: string): MenuModel;
    createModelColumns(count: number, columnType?: ObjectType): ChildModelOf<Column<any>>[];
    /**
     * Creates cells with values.
     *
     * If the column is of type NumberColumn a numeric value is set.
     * Otherwise, the value is similar to 'cell0_0' if rowId is given, or 'cell0' if no rowId is given.
     */
    createModelCells(columns: ColumnModel[] | number, rowId?: string): Cell[];
    /**
     * Creates #rowCount rows where columns are either the column count or the column objects.
     * Passing the column objects allows to consider the column type for cell creation.
     */
    createModelRows(columns: number | ColumnModel<any>[], rowCount: number, parentRow?: TableRow | string): TableRowModelWithCells[];
    createModelSingleColumnByTexts(texts: string[]): TableModelWithCells;
    createModelSingleColumnByValues(values: any[], columnType: ObjectType<Column>): TableModelWithCells;
    createModelFixture(colCount: number, rowCount?: number): TableModelWithCells;
    createTableWithOneColumn(): Table;
    createModelSingleConfiguredCheckableColumn(rowCount: number): TableModelWithCells;
    createTable(model: TableModel): SpecTable;
    createTableAdapter(model: InitModelOf<ModelAdapter> | TableModel & {
        session: Session;
        id: string;
    }): SpecTableAdapter;
    createColumnFilter(model: InitModelOf<TextColumnUserFilter>): TextColumnUserFilter;
    createAndRegisterColumnFilter(model: InitModelOf<TextColumnUserFilter>): TextColumnUserFilter;
    createTableTextFilter(table: Table, text: string): TableTextUserFilter;
    createTextColumnFilter(table: Table, column: Column, text: string): TextColumnUserFilter;
    createColumnStructureChangedEvent(model: {
        id: string;
    }, columns: ColumnModel[]): RemoteEvent;
    createRowsInsertedEvent(model: {
        id: string;
    }, rows: TableRowModel[]): RemoteEvent;
    createAllRowsDeletedEvent(model: {
        id: string;
    }): RemoteEvent;
    createFiltersChangedEvent(model: {
        id: string;
    }, filters: Filter<TableRow>[]): RemoteEvent;
    /**
     * Applies display style on rows and cells so that cells are positioned correctly in a row.<br>
     * Necessary because the stylesheet is not applied when running the specs.
     */
    applyDisplayStyle(table: Table): void;
    getRowIds(rows: ObjectOrModel<TableRow>[]): string[];
    selectRowsAndAssert(table: Table, rows: TableRow[]): void;
    assertSelection(table: Table, rows: TableRow[]): void;
    /**
     * Asserts that the rows contain the given texts at column specified by colIndex
     * @param texts array with same length as rows.
     */
    assertTextsInCells(rows: TableRow[], colIndex: number, texts: string[]): void;
    assertValuesInCells(rows: TableRow[], colIndex: number, values: any[]): void;
    assertDatesInCells(rows: TableRow[], colIndex: number, dates: Date[]): void;
    assertSelectionEvent(id: string, rowIds: string[]): void;
    getDisplayingContextMenu(table: Table): JQuery;
    /**
     * Since scout.comparators.TEXT is a static object and only installed once,
     * we must reset the object - otherwise we could not test cases with client
     * and server side sorting.
     */
    resetIntlCollator(): void;
}
export type TableRowModelWithCells = TableRowModel & {
    cells: Cell[];
};
export type TableModelWithCells = TableModel & {
    id: string;
    parent: Widget;
    session: Session;
    objectType: ObjectType<Table>;
};
//# sourceMappingURL=TableSpecHelper.d.ts.map