/// <reference types="jquery" />
import { Action, Alignment, BooleanColumn, Cell, CellEditorPopup, Column, CompactColumn, Comparator, ContextMenuPopup, Desktop, DesktopPopupOpenEvent, DisplayViewId, DoubleClickSupport, DragAndDropHandler, DropType, EnumObject, EventHandler, Filter, FilterOrFunction, FilterResult, FilterSupport, IconColumn, InitModelOf, Insets, KeyStrokeContext, LoadingSupport, Menu, MenuBar, MenuDestinations, NumberColumn, NumberColumnAggregationFunction, NumberColumnBackgroundEffect, ObjectOrChildModel, ObjectOrModel, Predicate, PropertyChangeEvent, Range, ScrollToOptions, Status, StatusOrModel, TableCompactHandler, TableControl, TableEventMap, TableFooter, TableHeader, TableModel, TableRow, TableRowModel, TableSelectionHandler, TableTileGridMediator, TableTooltip, TableUpdateBuffer, TableUserFilter, TableUserFilterModel, Tile, TileTableHeaderBox, UpdateFilteredElementsOptions, ValueField, Widget } from '../index';
export declare class Table extends Widget implements TableModel {
    model: TableModel;
    eventMap: TableEventMap;
    self: Table;
    columnMap: ColumnMap;
    autoResizeColumns: boolean;
    columnAddable: boolean;
    columnLayoutDirty: boolean;
    columns: Column<any>[];
    contextColumn: Column<any>;
    checkable: boolean;
    displayViewId: DisplayViewId;
    checkableStyle: TableCheckableStyle;
    cellEditorPopup: CellEditorPopup<any>;
    compact: boolean;
    openFieldPopupOnCellEdit: boolean;
    compactHandler: TableCompactHandler;
    compactColumn: CompactColumn;
    dropType: DropType;
    dropMaximumSize: number;
    dragAndDropHandler: DragAndDropHandler;
    groupingStyle: TableGroupingStyle;
    header: TableHeader;
    tableStatus: Status;
    rowBorders: Insets;
    headerEnabled: boolean;
    headerVisible: boolean;
    headerMenusEnabled: boolean;
    hasReloadHandler: boolean;
    hierarchical: boolean;
    hierarchicalStyle: TableHierarchicalStyle;
    keyStrokes: Action[];
    menus: Menu[];
    menuBar: MenuBar;
    menuBarVisible: boolean;
    contextMenu: ContextMenuPopup;
    multiCheck: boolean;
    multiSelect: boolean;
    multilineText: boolean;
    scrollToSelection: boolean;
    selectedRows: TableRow[];
    sortEnabled: boolean;
    tableControls: TableControl[];
    tableStatusVisible: boolean;
    tableTileGridMediator: TableTileGridMediator;
    tileMode: boolean;
    tileTableHeader: TileTableHeaderBox;
    tileProducer: (row: TableRow) => Tile;
    footer: TableFooter;
    footerVisible: boolean;
    filters: Filter<TableRow>[];
    /**
     * Contains all rows of the table.
     */
    rows: TableRow[];
    /**
     * Contains only the root rows of the table.
     * If the table is not {@link hierarchical}, it is the same as {@link rows}.
     */
    rootRows: TableRow[];
    /**
     * Contains only the rows that are expanded and accepted by all filters.
     */
    visibleRows: TableRow[];
    estimatedRowCount: number;
    maxRowCount: number;
    aggregateRowHeight: number;
    truncatedCellTooltipEnabled: boolean;
    checkableColumn: BooleanColumn;
    rowIconColumn: IconColumn;
    uiCssClass: string;
    /** visible rows by id */
    visibleRowsMap: Record<string, TableRow>;
    rowLevelPadding: number;
    /** rows by id */
    rowsMap: Record<string, TableRow>;
    rowHeight: number;
    rowWidth: number;
    /** read-only, set by _calculateRowInsets(), also used in TableHeader.js */
    rowInsets: Insets;
    /** read-only, set by _calculateRowInsets(), also used in TableLayout.js */
    rowMargins: Insets;
    rowIconVisible: boolean;
    rowIconColumnWidth: number;
    staticMenus: Menu[];
    selectionHandler: TableSelectionHandler;
    tooltips: TableTooltip[];
    tableNodeColumn: Column<any>;
    updateBuffer: TableUpdateBuffer;
    /**
     * Initial value must be > 0 to make prefSize work (if it is 0, no filler will be generated).
     * If rows have a variable height, prefSize is only correct for 10 rows.
     * Layout will adjust this value depending on the view port size.
     */
    viewRangeSize: number;
    viewRangeDirty: boolean;
    viewRangeRendered: Range;
    virtual: boolean;
    textFilterEnabled: boolean;
    filterSupport: FilterSupport<TableRow>;
    filteredElementsDirty: boolean;
    $data: JQuery;
    $emptyData: JQuery;
    $fillBefore: JQuery;
    $fillAfter: JQuery;
    /** @internal */
    _renderViewportBlocked: boolean;
    /** @internal */
    _filterMenusHandler: (menuItems: Menu[], destination: MenuDestinations) => Menu[];
    /** @internal */
    _aggregateRows: AggregateTableRow[];
    protected _filteredRows: TableRow[];
    protected _maxLevel: number;
    protected _animationRowLimit: number;
    protected _blockLoadThreshold: number;
    protected _doubleClickSupport: DoubleClickSupport;
    protected _permanentHeadSortColumns: Column<any>[];
    protected _permanentTailSortColumns: Column<any>[];
    protected _popupOpenHandler: EventHandler<DesktopPopupOpenEvent>;
    protected _rerenderViewPortAfterAttach: boolean;
    protected _renderViewPortAfterAttach: boolean;
    protected _triggerRowsSelectedPending: boolean;
    protected _animateAggregateRows: boolean;
    protected _postAttachActions: (() => void)[];
    protected _desktopPropertyChangeHandler: EventHandler<PropertyChangeEvent<any, Desktop>>;
    protected _imageLoadListener: (event: ErrorEvent) => void;
    protected _insertedRows: TableRow[];
    protected _$mouseDownRow: JQuery;
    protected _mouseDownRowId: string;
    protected _mouseDownColumn: Column<any>;
    constructor();
    static MenuTypes: {
        /**
         * The menu is always visible and displayed first in the {@link MenuBar}.
         * The menu won't be displayed in the context menu.
         */
        readonly EmptySpace: "Table.EmptySpace";
        /**
         * The menu is only visible if exactly one row has been selected.
         * The menu is also displayed in the context menu.
         */
        readonly SingleSelection: "Table.SingleSelection";
        /**
         * The menu is only visible if at least two row have been selected.
         * The menu is also displayed in the context menu.
         */
        readonly MultiSelection: "Table.MultiSelection";
        /**
         * The menu is displayed in the {@link TableHeader} on the right side.
         */
        readonly Header: "Table.Header";
    };
    static HierarchicalStyle: {
        readonly DEFAULT: "default";
        readonly STRUCTURED: "structured";
    };
    static GroupingStyle: {
        /**
         * Aggregate row is rendered on top of the row-group.
         */
        readonly TOP: "top";
        /**
         * Aggregate row is rendered on the bottom of the row-group (default).
         */
        readonly BOTTOM: "bottom";
    };
    static CheckableStyle: {
        /**
         * When row is checked a boolean column with a checkbox is inserted into the table.
         */
        readonly CHECKBOX: "checkbox";
        /**
         * When a row is checked the table-row is marked as checked. By default, a background
         * color is set on the table-row when the row is checked.
         */
        readonly TABLE_ROW: "tableRow";
        /**
         * Like the CHECKBOX Style but a click anywhere on the row triggers the check.
         */
        readonly CHECKBOX_TABLE_ROW: "checkbox_table_row";
    };
    /**
     * This enum defines the reload-reasons for a table reload operation
     */
    static ReloadReason: {
        /**
         * No specific reason, just reload data using the current search settings, the current row limits and the current
         * filter (Default)
         */
        readonly UNSPECIFIED: "unspecified";
        /**
         * Some search parameters changed or the search was reset and the search was triggered
         */
        readonly SEARCH: "search";
        /**
         * The user requested loading more data than his soft limit, up to the application specific hard limit
         */
        readonly OVERRIDE_ROW_LIMIT: "overrideRowLimit";
        /**
         * The user requested loading no more data than his soft limit;
         */
        readonly RESET_ROW_LIMIT: "resetRowLimit";
        /**
         * The column structure of the table was changed
         */
        readonly ORGANIZE_COLUMNS: "organizeColumns";
        /**
         * Any call to IPage#dataChanged
         */
        readonly DATA_CHANGED_TRIGGER: "dataChangedTrigger";
    };
    static SELECTION_CLASSES: string;
    protected _init(model: InitModelOf<this>): void;
    protected _initRow(row: ObjectOrModel<TableRow>): TableRow;
    protected _createRow(rowModel: TableRowModel): TableRow;
    protected _initColumns(): void;
    protected _destroy(): void;
    protected _destroyColumns(): void;
    protected _calculateTableNodeColumn(): void;
    protected _createLoadingSupport(): LoadingSupport;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _initKeyStrokeContext(): void;
    protected _initTableKeyStrokeContext(): void;
    protected _insertBooleanColumn(): void;
    protected _insertRowIconColumn(): void;
    handleAppLinkAction(event: JQuery.KeyboardEventBase): void;
    /** @internal */
    _isDataRendered(): boolean;
    protected _render(): void;
    /** @internal */
    _renderData(): void;
    protected _renderProperties(): void;
    protected _setCssClass(cssClass: string): void;
    /** @internal */
    _removeData(): void;
    protected _remove(): void;
    setRowLevelPadding(rowLevelPadding: number): void;
    protected _renderRowLevelPadding(): void;
    setTableControls(controls: ObjectOrChildModel<TableControl>[]): void;
    protected _renderTableControls(): void;
    protected _setTableControls(controls: TableControl[]): void;
    /**
     * When an IMG has been loaded we must update the stored height in the model-row.
     * Note: we don't change the width of the row or table.
     */
    protected _onImageLoadOrError(event: ErrorEvent): void;
    protected _onRowMouseDown(event: JQuery.MouseDownEvent): boolean;
    protected _isRowControl($target: JQuery): boolean;
    protected _onRowMouseUp(event: JQuery.MouseUpEvent): void;
    protected _onRowDoubleClick(event: JQuery.DoubleClickEvent): void;
    showContextMenu(options: {
        pageX?: number;
        pageY?: number;
    }): void;
    protected _showContextMenu(options: {
        pageX?: number;
        pageY?: number;
    }): void;
    isRowSelectedAndVisible(row: TableRow): boolean;
    getLastSelectedAndVisibleRow(): TableRow;
    onColumnVisibilityChanged(): void;
    protected _onScroll(event: JQuery.ScrollEvent): void;
    protected _renderTableStatus(): void;
    setContextColumn(contextColumn: Column<any>): void;
    protected _hasVisibleTableControls(): boolean;
    hasAggregateTableControl(): boolean;
    protected _createHeader(): TableHeader;
    protected _createFooter(): TableFooter;
    protected _installCellTooltipSupport(): void;
    protected _uninstallCellTooltipSupport(): void;
    /** @internal */
    _cellTooltipText($cell: JQuery): string;
    /** @see TableModel.truncatedCellTooltipEnabled */
    setTruncatedCellTooltipEnabled(truncatedCellTooltipEnabled: boolean): void;
    /**
     * Decides if a cell tooltip should be shown for a truncated cell.
     */
    protected _isTruncatedCellTooltipEnabled(column: Column<any>): boolean;
    protected _isAggregatedTooltip($cell: JQuery): boolean;
    reload(reloadReason?: string): void;
    setLoading(loading: boolean): void;
    exportToClipboard(): void;
    /**
     * JS implementation of AbstractTable.execCopy(rows)
     */
    protected _exportToClipboard(): void;
    protected _selectedRowsToText(): string;
    protected _unwrapText(text?: string): string;
    /** @see TableModel.multiSelect */
    setMultiSelect(multiSelect: boolean): void;
    toggleSelection(): void;
    selectAll(): void;
    deselectAll(): void;
    checkAll(checked?: boolean, options?: TableRowCheckOptions): void;
    uncheckAll(options?: TableRowCheckOptions): void;
    updateScrollbars(): void;
    protected _sort(animateAggregateRows?: boolean): boolean;
    /**
     * @returns whether or not sorting is possible. Asks each column to answer this question by calling Column#isSortingPossible.
     */
    protected _isSortingPossible(sortColumns: Column<any>[]): boolean;
    protected _sortColumns(): Column<any>[];
    protected _sortImpl(sortColumns: Column<any>[]): void;
    /**
     * Pre-order (top-down) traversal of all rows in this table (if hierarchical).
     */
    visitRows(visitFunc: (row: TableRow, level: number) => void, rows?: TableRow[], level?: number): void;
    protected _sortHierarchical(sortFunc: Comparator<TableRow>, rows?: TableRow[]): void;
    protected _renderRowOrderChanges(): void;
    /** @see TableModel.sortEnabled */
    setSortEnabled(sortEnabled: boolean): void;
    /**
     * @param column the column to sort by.
     * @param direction the sorting direction. Either 'asc' or 'desc'. If not specified the direction specified by the column is used {@link Column.sortAscending}.
     * @param multiSort true to add the column to the list of sorted columns. False to use this column exclusively as sort column (reset other columns). Default is false.
     * @param remove true to remove the column from the sort columns. Default is false.
     */
    sort(column: Column<any>, direction?: 'asc' | 'desc', multiSort?: boolean, remove?: boolean): void;
    protected _addSortColumn(column: Column<any>, direction?: 'asc' | 'desc', multiSort?: boolean): void;
    /**
     * Intended to be called for new sort columns.
     * Sets the sortIndex of the given column and its siblings.
     */
    protected _updateSortIndexForColumn(column: Column<any>, multiSort: boolean): void;
    protected _removeSortColumn(column: Column<any>): void;
    protected _removeSortColumnInternal(column: Column<any>): void;
    isGroupingPossible(column: Column<any>): boolean;
    isAggregationPossible(column: Column<any>): boolean;
    changeAggregation(column: NumberColumn, func: NumberColumnAggregationFunction): void;
    changeAggregations(columns: NumberColumn[], functions: NumberColumnAggregationFunction[]): void;
    protected _addGroupColumn(column: Column<any>, direction?: 'asc' | 'desc', multiGroup?: boolean): void;
    protected _removeGroupColumn(column: Column<any>): void;
    protected _buildRowDiv(row: TableRow): string;
    protected _calculateRowInsets(): void;
    /** @internal */
    _updateRowWidth(): void;
    /**
     * A html element with display: table-cell gets the wrong width in Chrome when zoom is enabled, see
     * https://bugs.chromium.org/p/chromium/issues/detail?id=740502.
     * Because the table header items don't use display: table-cell, theirs width is correct.
     * -> Header items and table cells are not in sync which is normally not a big deal but gets visible very well with a lot of columns.
     * This method reads the real width and stores it on the column so that the header can use it when setting the header item's size.
     * It is also necessary to update the row width accordingly otherwise it would be cut at the very right.
     * @internal
     */
    _updateRealColumnWidths($row?: JQuery): boolean;
    protected _updateRealColumnWidth(column: Column<any>, colIndex?: number, $row?: JQuery): boolean;
    protected _updateRowHeight(): void;
    /**
     * Updates the row heights for every visible row and aggregate row and clears the height of the others
     */
    protected _updateRowHeights(): void;
    protected _renderRowsInRange(range: Range): void;
    protected _rowsRenderedInfo(): string;
    /**
     * Moves the row to the top.
     */
    moveRowToTop(row: TableRow): void;
    /**
     * Moves the row to the bottom.
     */
    moveRowToBottom(row: TableRow): void;
    /**
     * Moves the row one up, disregarding filtered rows.
     */
    moveRowUp(row: TableRow): void;
    /**
     * Moves the row one down, disregarding filtered rows.
     */
    moveRowDown(row: TableRow): void;
    moveVisibleRowUp(row: TableRow): void;
    moveVisibleRowDown(row: TableRow): void;
    moveRow(sourceIndex: number, targetIndex: number): void;
    protected _removeRowsInRange(range: Range): void;
    removeAllRows(): void;
    /**
     *
     * @param rows if undefined, all rows are removed
     */
    protected _removeRows(rows?: TableRow | TableRow[]): void;
    /**
     * Just removes the row, does NOT adjust this.viewRangeRendered
     */
    protected _removeRow(row: TableRow | AggregateTableRow): void;
    /**
     * Animates the rendering of a row by setting it to invisible before doing a slideDown animation. The row needs to already be rendered.
     */
    protected _showRow(row: TableRow | AggregateTableRow): void;
    /**
     * Animates the removal of a row by doing a slideUp animation. The row will be removed after the animation finishes.
     */
    protected _hideRow(row: TableRow | AggregateTableRow): void;
    /**
     * This method should be used after a row is added to the DOM (new rows, updated rows). The 'row'
     * is expected to be linked with the corresponding '$row' (row.$row and $row.data('row')).
     */
    protected _installRow(row: TableRow): void;
    /** @internal */
    _calcRowLevelPadding(row: {
        parentRow?: TableRow;
    }): number;
    protected _showCellErrorForRow(row: TableRow): void;
    protected _showCellError(row: TableRow, $cell: JQuery, errorStatus: Status): void;
    /**
     * @returns the column at position x (e.g. from event.pageX)
     */
    protected _columnAtX(x: number): Column<any>;
    protected _find$AppLink(event: JQuery.MouseUpEvent): JQuery;
    /** @internal */
    _filterMenus(menuItems: Menu[], destination: MenuDestinations, onlyVisible?: boolean, enableDisableKeyStrokes?: boolean, notAllowedTypes?: string | string[]): Menu[];
    /** @internal */
    _filterMenusForContextMenu(): Menu[];
    setStaticMenus(staticMenus: ObjectOrChildModel<Menu>[]): void;
    protected _removeMenus(): void;
    notifyRowSelectionFinished(): void;
    /** @internal */
    _triggerRowClick(originalEvent: JQuery.MouseEventBase, row: TableRow, mouseButton: number, column?: Column<any>): void;
    protected _triggerRowAction(row: TableRow, column: Column<any>): void;
    /**
     * Starts cell editing for the cell at the given column and row, but only if editing is allowed.
     * @see prepareCellEdit
     */
    focusCell(column: Column<any>, row: TableRow): void;
    /**
     * Creates a cell editor for the cell at the given column and row, ensures the row is selected and passes the editor
     * to {@link #startCellEdit} which starts the editing by rendering the editor in a {@link CellEditorPopup}.<br>
     * If the completion of a previous cell edit is still in progress, the preparation is delayed until the completion is finished.
     *
     * @param openFieldPopupOnCellEdit true to instruct the editor to open its control popup when the editor is rendered.
     *    This only has an effect if the editor has a popup (e.g. SmartField or DateField).
     * @returns The promise will be resolved when the preparation has been finished.
     */
    prepareCellEdit(column: Column<any>, row: TableRow, openFieldPopupOnCellEdit?: boolean): JQuery.Promise<void>;
    /**
     * @param openFieldPopupOnCellEdit when this parameter is set to true, the field instance may use this property (passed to onCellEditorRendered of the field)
     * to decide whether it should open a popup immediately after it is rendered. This is used for Smart- and DateFields. Default is false.
     */
    prepareCellEditInternal(column: Column<any>, row: TableRow, openFieldPopupOnCellEdit?: boolean): void;
    /**
     * @returns a cell for the given column and row. Row Icon column and cell icon column don't have cells --> generate one.
     */
    cell<TValue>(column: Column<TValue>, row: TableRow): Cell<TValue>;
    cellByCellIndex(cellIndex: number, row: TableRow): Cell;
    cellValue<TValue>(column: Column<TValue>, row: TableRow): TValue | string;
    cellText(column: Column<any>, row: TableRow): string;
    /**
     *
     * @returns the next editable position in the table, starting from the cell at (currentColumn / currentRow).
     * A position is an object containing row and column (cell has no reference to a row or column due to memory reasons).
     */
    nextEditableCellPos(currentColumn: Column<any>, currentRow: TableRow, reverse: boolean): TableCellPosition;
    nextEditableCellPosForRow(startColumnIndex: number, row: TableRow, reverse?: boolean): TableCellPosition;
    clearAggregateRows(animate?: boolean): void;
    /**
     * @internal
     * Executes the aggregate function with the given funcName for each visible column, but only if the Column
     * has that function, which is currently only the case for NumberColumns.
     *
     * @param states is a reference to an Array containing the results for each column.
     * @param row (optional) if set, an additional cell-value parameter is passed to the aggregate function
     */
    _forEachVisibleColumn(funcName: string, states: object[], row?: TableRow): void;
    /** @internal */
    _group(animate?: boolean): void;
    protected _isNewGroup(groupedColumns: Column<any>[], row: TableRow, nextRow: TableRow): boolean;
    protected _groupedColumns(): Column<any>[];
    /**
     * Inserts a new aggregation row between 'prevRow' and 'nextRow'.
     *
     * @param contents cells of the new aggregate row
     * @param prevRow row _before_ the new aggregate row
     * @param nextRow row _after_ the new aggregate row
     */
    protected _addAggregateRow(contents: any[], prevRow: TableRow, nextRow: TableRow): void;
    protected _removeAggregateRows(animate?: boolean): void;
    protected _renderAggregateRows(animate?: boolean): void;
    /** @internal */
    _build$AggregateRow(aggregateRow?: AggregateTableRow): JQuery;
    groupColumn(column: Column<any>, multiGroup?: boolean, direction?: 'asc' | 'desc', remove?: boolean): void;
    removeColumnGrouping(column: Column<any>): void;
    removeAllColumnGroupings(): void;
    /**
     * @returns true if at least one column has grouped=true
     */
    isGrouped(): boolean;
    setColumnBackgroundEffect(column: NumberColumn, effect: NumberColumnBackgroundEffect): void;
    /**
     * Updates the background effect of every column, if column.backgroundEffect is set.
     * Meaning: Recalculates the min / max values and renders the background effect again.
     */
    protected _updateBackgroundEffect(): void;
    /**
     * Recalculates the values necessary for the background effect of every column, if column.backgroundEffect is set
     */
    protected _calculateValuesForBackgroundEffect(): void;
    protected _markAutoOptimizeWidthColumnsAsDirty(): void;
    protected _markAutoOptimizeWidthColumnsAsDirtyIfNeeded(autoOptimizeWidthColumns: Column<any>[], oldRow: TableRow, newRow: TableRow): boolean;
    /** @see TableModel.multiCheck */
    setMultiCheck(multiCheck: boolean): void;
    checkedRows(): TableRow[];
    checkRow(row: TableRow, checked?: boolean, options?: TableRowCheckOptions): void;
    checkRows(rows: TableRow | TableRow[], options?: TableRowCheckOptions): void;
    uncheckRow(row: TableRow, options?: TableRowCheckOptions): void;
    uncheckRows(rows: TableRow | TableRow[], options?: TableRowCheckOptions): void;
    isTableNodeColumn(column: Column<any>): boolean;
    collapseRow(row: TableRow): void;
    collapseAll(): void;
    expandAll(): void;
    collapseRows(rows: TableRow[], recursive?: boolean): void;
    expandRow(row: TableRow, recursive?: boolean): void;
    expandRows(rows: TableRow[], recursive?: boolean): void;
    /**
     * @param rows {@link rootRows} are used if not specified.
     * @param expanded Default is true.
     * @param recursive Default is false.
     */
    expandRowsInternal(rows?: TableRow[], expanded?: boolean, recursive?: boolean): void;
    doRowAction(row: TableRow, column?: Column<any>): void;
    insertRow(row: ObjectOrModel<TableRow>): void;
    insertRows(rows: ObjectOrModel<TableRow> | ObjectOrModel<TableRow>[]): void;
    protected _sortAfterInsert(wasEmpty: boolean): void;
    protected _sortWhileInit(): void;
    deleteRow(row: TableRow): void;
    deleteRows(rows: TableRow | TableRow[]): void;
    deleteAllRows(): void;
    updateRow(row: ObjectOrModel<TableRow>): void;
    updateRows(rows: ObjectOrModel<TableRow> | ObjectOrModel<TableRow>[]): void;
    protected _renderUpdateRows(rows: TableRow[], oldRowsMap: Record<string, TableRow>): void;
    protected _sortAfterUpdate(): void;
    isHierarchical(): boolean;
    protected _setHierarchical(hierarchical: boolean): void;
    /**
     * The given rows must be rows of this table in desired order.
     */
    updateRowOrder(rows: TableRow | TableRow[]): void;
    protected _destroyTooltipsForRow(row: TableRow | AggregateTableRow): void;
    protected _destroyCellEditorForRow(row: TableRow | AggregateTableRow): void;
    startCellEdit<TValue>(column: Column<TValue>, row: TableRow, field: ValueField<TValue>): CellEditorPopup<TValue>;
    /**
     * @param saveEditorValue when this parameter is set to true, the value of the editor field is set as
     *    new value on the edited cell. In remote case this parameter is always false, because the cell
     *    value is updated by an updateRow event instead. Default is false.
     */
    endCellEdit(field: ValueField<any>, saveEditorValue?: boolean): void;
    protected _updateCellFromEditor<TValue>(cellEditorPopup: CellEditorPopup<TValue>, field: ValueField<TValue>, saveEditorValue?: boolean): void;
    completeCellEdit(): void;
    cancelCellEdit(): void;
    scrollTo(row: TableRow, options?: ScrollToOptions | string): void;
    scrollPageUp(): void;
    scrollPageDown(): void;
    setScrollTop(scrollTop: number): void;
    /** @internal */
    _renderScrollTop(): void;
    get$Scrollable(): JQuery;
    /** @see TableModel.scrollToSelection */
    setScrollToSelection(scrollToSelection: boolean): void;
    revealSelection(): void;
    revealChecked(): void;
    rowById(id: string): TableRow;
    rowsByIds(ids: string[]): TableRow[];
    rowsToIds(rows: TableRow[]): string[];
    /**
     * Checks whether the given row is contained in the table. Uses the id of the row for the lookup.
     */
    hasRow(row: TableRow): boolean;
    /**
     * render borders and selection of row. default select if no argument or false is passed in deselect
     * model has to be updated before calling this method.
     */
    protected _renderSelection(rows?: TableRow | TableRow[]): void;
    /** @internal */
    _removeSelection(): void;
    protected _renderNoRowsSelectedMarker(): void;
    addRowToSelection(row: TableRow, ongoingSelection?: boolean): void;
    removeRowFromSelection(row: TableRow, ongoingSelection?: boolean): void;
    selectRow(row: TableRow, debounceSend?: boolean): void;
    selectRows(rows: TableRow | TableRow[], debounceSend?: boolean): void;
    deselectRow(row: TableRow): void;
    deselectRows(rows: TableRow | TableRow[]): void;
    isRowSelected(row: TableRow): boolean;
    filterCount(): number;
    filteredRows(): TableRow[];
    $rows(includeAggrRows?: boolean): JQuery;
    $aggregateRows(): JQuery;
    /**
     * @returns the first selected row of this table or null when no row is selected
     */
    selectedRow(): TableRow;
    $selectedRows(): JQuery;
    $cellsForColIndex(colIndex: number, includeAggrRows: boolean): JQuery;
    $cellsForRow($row: JQuery): JQuery;
    /**
     * @param column or columnIndex
     */
    $cell(column: Column<any> | number, $row: JQuery): JQuery;
    columnById<TId extends string & keyof ColumnMapOf<this>>(columnId: TId): ColumnMapOf<this>[TId];
    /**
     * @param $cell the $cell to get the column for
     * @param $row the $row which contains the $cell. If not passed it will be determined automatically
     * @returns the column for the given $cell
     */
    columnFor$Cell($cell: JQuery, $row?: JQuery): Column<any>;
    columnsByIds<TId extends string & keyof ColumnMapOf<this>>(columnIds: TId[]): ColumnMapOf<this>[TId][];
    getVisibleRows(): TableRow[];
    protected _updateRowStructure(options: UpdateTableRowStructureOptions): void;
    protected _rebuildTreeStructure(): void;
    protected _updateFilteredRows(applyFilters?: boolean, changed?: boolean): void;
    protected _updateVisibleRows(): void;
    protected _computeVisibleRows(rows?: TableRow[]): TableRow[];
    visibleChildRows(row: TableRow): TableRow[];
    protected _renderRowDelta(): void;
    /**
     * Sorts the given $rows according to the row index
     */
    protected _order$Rows($rows?: JQuery): JQuery;
    protected _order$AggregateRows($rows?: JQuery): void;
    /**
     * @returns true if row state has changed, false if not
     */
    protected _applyFiltersForRow(row: TableRow): boolean;
    /**
     * @returns labels of the currently active Filters that provide a createLabel() function
     */
    filteredBy(): string[];
    resetUserFilter(applyFilter?: boolean): void;
    hasUserFilter(): boolean;
    resizeToFit(column: Column<any>, maxWidth?: number): void;
    protected _resizeToFit(column: Column<any>, maxWidth?: number, calculatedSize?: number): void;
    /**
     * @param filter The filter to add.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    addFilter(filter: FilterOrFunction<TableRow>, applyFilter?: boolean): void;
    /**
     * @param filter The filter to remove.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    removeFilter(filter: FilterOrFunction<TableRow>, applyFilter?: boolean): void;
    removeFilterByKey(key: string, applyFilter?: boolean): void;
    getFilter(key: string): Filter<TableRow>;
    /**
     * @param filter The new filters.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     * @see TableModel.filters
     */
    setFilters(filters: (FilterOrFunction<TableRow> | ObjectOrModel<TableUserFilter>)[], applyFilter?: boolean): void;
    protected _ensureFilter<T extends Filter<TableRow>>(filter: TableUserFilterModel | FilterOrFunction<TableRow>): Filter<TableRow>;
    filter(): void;
    protected _filter(options?: UpdateTableRowStructureOptions): void;
    protected _createFilterSupport(): FilterSupport<TableRow>;
    /** @see TableModel.textFilterEnabled */
    setTextFilterEnabled(textFilterEnabled: boolean): void;
    isTextFilterFieldVisible(): boolean;
    protected _renderTextFilterEnabled(): void;
    updateFilteredElements(result: FilterResult<TableRow>, opts: UpdateFilteredElementsOptions): void;
    /**
     * Resizes the given column to the new size.
     *
     * @param column column to resize
     * @param width new column size
     */
    resizeColumn(column: Column<any>, width: number): void;
    protected _renderResizeColumn(column: Column<any>, width: number): void;
    /** @internal */
    _resizeAggregateCell($cell: JQuery): void;
    /**
     * @internal
     * Gets the aggregation cell range. this is the range from one aggregation cell with content to the next (or the table end).
     * @param $cell The cell to get the surrounding range
     * @returns All cells of the range to which the given cell belongs
     */
    _getAggrCellRange($cell: JQuery): JQuery[];
    /**
     * Updates the width and icon visibility of an aggregate cell in groupingStyle=title
     * @param $cell The aggregation cell that should be updated.
     */
    protected _updateAggrCell($cell: JQuery): void;
    protected _getWidthWithMarginCached($element: JQuery): number;
    /**
     * Gets the computed space that is available to the content of the cell.
     *
     * @param $cell The aggregation cell for which the info should be computed
     * @param $icon The icon of the cell. May be null.
     * @returns The unused space available into flow direction of the cell til the end of the table or the next cell with content.
     */
    protected _getAggrCellWidth($cell: JQuery, $icon: JQuery): number;
    /**
     * Sets the aggregation cell icon visible or not depending on the space available.
     * If the available space is big enough to hold the content of the cell text and the icon, the icon will become visible. Otherwise, the icon will be hidden.
     * This way no ellipsis will be shown as long as there is enough space for the text only.
     *
     * @param $icon The icon for which the visibility should be changed
     * @param $cellText The element holding the text of the cell. Required to compute if there is still enough space for text and icon or not
     * @param spaceAvailableForText The newly computed space available for the cell text.
     * @returns The new space available for the text. If the visibility of the icon changed, more or less space might become available.
     */
    protected _updateAggrIconVisibility($icon: JQuery, $cellText: JQuery, spaceAvailableForText: number): number;
    moveColumn(column: Column<any>, visibleOldPos: number, visibleNewPos: number, dragged?: boolean): void;
    /**
     * Ensures the given newPos does not pass a fixed column boundary (necessary when moving columns)
     */
    protected _considerFixedPositionColumns(visibleOldPos: number, visibleNewPos: number): number;
    protected _renderColumnOrderChanges(oldColumnOrder: Column<any>[]): void;
    protected _triggerRowsInserted(rows: TableRow[]): void;
    protected _triggerRowsDeleted(rows: TableRow[]): void;
    protected _triggerRowsUpdated(rows: TableRow[]): void;
    protected _triggerAllRowsDeleted(rows: TableRow[]): void;
    protected _triggerRowsSelected(debounce?: boolean): void;
    protected _triggerRowsChecked(rows: TableRow[]): void;
    protected _triggerRowsExpanded(rows: TableRow[]): void;
    protected _triggerFilter(): void;
    protected _triggerFilterReset(): void;
    protected _triggerAppLinkAction(column: Column<any>, row: TableRow, ref: string, $appLink: JQuery): void;
    protected _triggerReload(reloadReason?: string): void;
    protected _triggerClipboardExport(): void;
    protected _triggerRowOrderChanged(row?: TableRow, animating?: boolean): void;
    protected _triggerColumnResized(column: Column<any>): void;
    protected _triggerColumnResizedToFit(column: Column<any>): void;
    protected _triggerColumnMoved(column: Column<any>, oldPos: number, newPos: number, dragged?: boolean): void;
    protected _triggerAggregationFunctionChanged(column: NumberColumn): void;
    /** @see TableModel.headerVisible */
    setHeaderVisible(visible: boolean): void;
    protected _renderHeaderVisible(): void;
    /** @see TableModel.headerEnabled */
    setHeaderEnabled(headerEnabled: boolean): void;
    protected _renderHeaderEnabled(): void;
    /** @see TableModel.headerMenusEnabled */
    setHeaderMenusEnabled(headerMenusEnabled: boolean): void;
    hasPermanentHeadOrTailSortColumns(): boolean;
    protected _setHeadAndTailSortColumns(): void;
    /** @see TableModel.tileMode */
    setTileMode(tileMode: boolean): void;
    protected _setTileMode(tileMode: boolean): void;
    protected _ensureMediator(): void;
    protected _renderTileMode(): void;
    createTiles(rows: TableRow[]): Tile[];
    protected _adaptTile(tile: Tile): void;
    createTileForRow(row: TableRow): Tile;
    /** @see TableModel.tileProducer */
    setTileProducer(tileProducer: (row: TableRow) => Tile): void;
    protected _setTileTableHeader(tileTableHeader: TileTableHeaderBox): void;
    protected _createTileTableHeader(): TileTableHeaderBox;
    /** @see TableModel.rowIconVisible */
    setRowIconVisible(rowIconVisible: boolean): void;
    protected _setRowIconVisible(rowIconVisible: boolean): void;
    protected _renderRowIconVisible(): void;
    protected _renderRowIconColumnWidth(): void;
    /** @see TableModel.rowIconColumnWidth */
    setRowIconColumnWidth(width: number): void;
    protected _setRowIconColumnWidth(width: number): void;
    protected _setSelectedRows(selectedRows: TableRow[] | string[]): void;
    /** @see TableModel.menus */
    setMenus(menus: ObjectOrChildModel<Menu>[]): void;
    protected _setMenus(menus: Menu[]): void;
    setMenuBarVisible(visible: boolean): void;
    protected _setMenuBarVisible(visible: boolean): void;
    protected _renderMenuBarVisible(): void;
    /** @internal */
    _refreshMenuBarPosition(): void;
    protected _createMenuBar(): MenuBar;
    protected _updateMenuBar(): void;
    protected _refreshMenuBarClasses(): void;
    protected _setKeyStrokes(keyStrokes: Action[]): void;
    setTableStatus(status: StatusOrModel): void;
    protected _setTableStatus(status: StatusOrModel): void;
    /** @see TableModel.tableStatusVisible */
    setTableStatusVisible(visible: boolean): void;
    protected _updateFooterVisibility(): void;
    /** @see TableModel.hierarchicalStyle */
    setHierarchicalStyle(style: TableHierarchicalStyle): void;
    protected _renderHierarchicalStyle(): void;
    /** @see TableModel.footerVisible */
    setFooterVisible(visible: boolean): void;
    /**
     * Renders the background effect of every column, if column.backgroundEffect is set
     */
    protected _renderBackgroundEffect(): void;
    protected _renderRowChecked(row: TableRow): void;
    /** @see TableModel.checkable */
    setCheckable(checkable: boolean): void;
    protected _setCheckable(checkable: boolean): void;
    protected _updateCheckableColumn(): void;
    protected _renderCheckable(): void;
    setCheckableStyle(checkableStyle: TableCheckableStyle): void;
    protected _setCheckableStyle(checkableStyle: TableCheckableStyle): void;
    protected _renderCheckableStyle(): void;
    /** @see TableModel.compact */
    setCompact(compact: boolean): void;
    protected _setCompact(compact: boolean): void;
    protected _updateCompactColumn(): boolean;
    protected _insertCompactColumn(): void;
    protected _renderCompact(): void;
    setGroupingStyle(groupingStyle: TableGroupingStyle): void;
    protected _setGroupingStyle(groupingStyle: TableGroupingStyle): void;
    protected _renderGroupingStyle(): void;
    redraw(): void;
    protected _rerenderHeaderColumns(): void;
    /** @internal */
    _renderTableHeader(): void;
    protected _removeTableHeader(): void;
    /**
     * @param width optional width of emptyData, if omitted the width is set to the header's scrollWidth.
     */
    protected _renderEmptyData(): void;
    protected _removeEmptyData(): void;
    protected _renderFooterVisible(): void;
    protected _renderFooter(): void;
    protected _removeFooter(): void;
    protected _renderEnabled(): void;
    protected _renderDisabledStyle(): void;
    /** @see TableModel.autoResizeColumns */
    setAutoResizeColumns(autoResizeColumns: boolean): void;
    protected _renderAutoResizeColumns(): void;
    /** @see TableModel.multilineText */
    setMultilineText(multilineText: boolean): void;
    protected _renderMultilineText(): void;
    /** @see TableModel.dropType */
    setDropType(dropType: DropType): void;
    protected _renderDropType(): void;
    /** @see TableModel.dropMaximumSize */
    setDropMaximumSize(dropMaximumSize: number): void;
    protected _installOrUninstallDragAndDropHandler(): void;
    /**
     * This listener is used to invalidate table layout when an image icon has been loaded (which happens async in the browser).
     */
    protected _installImageListeners(): void;
    protected _uninstallImageListeners(): void;
    /**
     * Calculates the optimal view range size (number of rows to be rendered).
     * It uses the default row height to estimate how many rows fit in the view port.
     * The view range size is this value * 2.
     */
    calculateViewRangeSize(): number;
    setViewRangeSize(viewRangeSize: number): void;
    protected _calculateCurrentViewRange(): Range;
    /**
     * Returns the index of the row which is at position scrollTop.
     * @internal
     */
    _rowIndexAtScrollTop(scrollTop: number): number;
    protected _heightForRow(row: TableRow): number;
    protected _measureRowHeight($row: JQuery): number;
    /**
     * Returns a range of size this.viewRangeSize. Start of range is rowIndex - viewRangeSize / 4.
     * -> 1/4 of the rows are before the viewport 2/4 in the viewport 1/4 after the viewport,
     * assuming viewRangeSize is 2*number of possible rows in the viewport (see calculateViewRangeSize).
     */
    protected _calculateViewRangeForRowIndex(rowIndex: number): Range;
    /**
     * Calculates and renders the rows which should be visible in the current viewport based on scroll top.
     * @internal
     */
    _renderViewport(): void;
    protected _rerenderViewport(): void;
    protected _renderViewRangeForRowIndex(rowIndex: number): void;
    /**
     * Renders the rows visible in the viewport and removes the other rows
     */
    protected _renderViewRange(viewRange: Range): void;
    protected _renderLastRowAtBottomMarker(): void;
    protected _lastVisibleRow(): TableRow;
    protected _removeRangeMarkers(): void;
    protected _renderRangeMarkers(): void;
    protected _modifyRangeMarkers(funcName: string): void;
    /**
     * Renders the view range that contains the given row.<br>
     * Does nothing if the row is already rendered or not visible (e.g. due to filtering).
     */
    ensureRowRendered(row: TableRow): void;
    protected _renderFiller(): void;
    protected _applyFillerStyle($filler: JQuery): void;
    protected _calculateFillerHeight(range: Range): number;
    containsAggregatedNumberColumn(): boolean;
    /**
     * Rebuilds the header.<br>
     * Does not modify the rows, it expects a deleteAll and insert operation to follow which will do the job.
     */
    updateColumnStructure(columns: Column<any>[]): void;
    updateColumnOrder(columns: (Column<any> | {
        id: string;
    })[]): void;
    /**
     * @param columns array of columns which were updated.
     */
    updateColumnHeaders(columns: Column[]): void;
    protected _attach(): void;
    /**
     * Method invoked when this is a 'detailTable' and the outline content is displayed.
     */
    protected _postAttach(): void;
    protected _renderOnAttach(): void;
    protected _rerenderViewportAfterAttach(): void;
    protected _renderViewportAfterAttach(): void;
    /**
     * Method invoked when this is a 'detailTable' and the outline content is not displayed anymore.
     */
    protected _detach(): void;
    /**
     * @param callback function to be called right after the popup is destroyed
     */
    protected _destroyCellEditorPopup(callback?: () => void): void;
    /** @see TableModel.virtual */
    setVirtual(virtual: boolean): void;
    setCellValue<TValue>(column: Column<TValue>, row: TableRow, value: TValue): void;
    setCellText(column: Column<any>, row: TableRow, displayText: string): void;
    setCellErrorStatus(column: Column<any>, row: TableRow, errorStatus: Status): void;
    visibleColumns(includeGuiColumns?: boolean): Column<any>[];
    displayableColumns(includeGuiColumns?: boolean): Column<any>[];
    filterColumns(filter: Predicate<Column<any>>, includeGuiColumns?: boolean): Column<any>[];
    protected _onDesktopPopupOpen(event: DesktopPopupOpenEvent): void;
    protected _onDesktopPropertyChange(event: PropertyChangeEvent<any, Desktop>): void;
    markRowsAsNonChanged(rows?: TableRow | TableRow[]): void;
    static parseHorizontalAlignment(alignment: Alignment): string;
    static linkRowToDiv(row: TableRow, $row: JQuery): void;
}
export type TableMenuTypes = EnumObject<typeof Table.MenuTypes>;
export type TableHierarchicalStyle = EnumObject<typeof Table.HierarchicalStyle>;
export type TableCheckableStyle = EnumObject<typeof Table.CheckableStyle>;
export type TableGroupingStyle = EnumObject<typeof Table.GroupingStyle>;
export type TableReloadReason = EnumObject<typeof Table.ReloadReason>;
export type UpdateTableRowStructureOptions = {
    /**
     * Default is false.
     */
    updateTree?: boolean;
    /**
     * Default is the value of {@link updateTree}.
     */
    filteredRows?: boolean;
    /**
     * Default is the value of {@link filteredRows}.
     */
    applyFilters?: boolean;
    /**
     * Default is false.
     */
    filtersChanged?: boolean;
    /**
     * Default is the value of {@link filteredRows}.
     */
    visibleRows?: boolean;
};
export type TableCellPosition = {
    column: Column<any>;
    row: TableRow;
};
export type TableRowCheckOptions = {
    checked?: boolean;
    checkOnlyEnabled?: boolean;
};
export type AggregateTableRow = {
    id?: string;
    contents: any[];
    prevRow: TableRow;
    nextRow: TableRow;
    $row?: JQuery;
    height?: number;
};
export type ColumnMap = {
    [type: string]: Column<any>;
};
export type ColumnMapOf<T> = T extends {
    columnMap: infer TMap;
} ? TMap : object;
//# sourceMappingURL=Table.d.ts.map