/// <reference types="jquery" />
import { AggregateTableRow, Alignment, Cell, CellEditorPopup, ColumnComparator, ColumnEventMap, ColumnModel, ColumnOptimalWidthMeasurer, ColumnUserFilter, Event, EventHandler, InitModelOf, ObjectType, PropertyEventEmitter, Session, SomeRequired, Status, Table, TableColumnMovedEvent, TableHeader, TableHeaderMenu, TableRow, ValueField } from '../../index';
export declare class Column<TValue = string> extends PropertyEventEmitter implements ColumnModel<TValue> {
    model: ColumnModel<TValue>;
    initModel: SomeRequired<this['model'], 'session'>;
    eventMap: ColumnEventMap;
    self: Column<any>;
    objectType: ObjectType<Column<TValue>>;
    id: string;
    autoOptimizeWidth: boolean;
    /** true if content of the column changed and width has to be optimized */
    autoOptimizeWidthRequired: boolean;
    session: Session;
    autoOptimizeMaxWidth: number;
    cssClass: string;
    compacted: boolean;
    editable: boolean;
    removable: boolean;
    modifiable: boolean;
    fixedWidth: boolean;
    fixedPosition: boolean;
    grouped: boolean;
    headerCssClass: string;
    headerIconId: string;
    headerHtmlEnabled: boolean;
    headerTooltipText: string;
    headerBackgroundColor: string;
    headerForegroundColor: string;
    headerFont: string;
    headerTooltipHtmlEnabled: boolean;
    horizontalAlignment: Alignment;
    htmlEnabled: boolean;
    initialAlwaysIncludeSortAtBegin: boolean;
    initialAlwaysIncludeSortAtEnd: boolean;
    index: number;
    initialized: boolean;
    guiOnly: boolean;
    mandatory: boolean;
    optimalWidthMeasurer: ColumnOptimalWidthMeasurer;
    sortActive: boolean;
    checkable: boolean;
    sortAscending: boolean;
    sortIndex: number;
    summary: boolean;
    type: string;
    width: number;
    initialWidth: number;
    minWidth: number;
    showSeparator: boolean;
    table: Table;
    tableNodeColumn: boolean;
    maxLength: number;
    text: string;
    textWrap: boolean;
    filterType: string;
    comparator: ColumnComparator;
    displayable: boolean;
    visible: boolean;
    textBased: boolean;
    headerMenuEnabled: boolean;
    tableNodeLevel0CellPadding: number;
    expandableIconLevel0CellPadding: number;
    nodeColumnCandidate: boolean;
    /** Set by TableHeader */
    $header: JQuery;
    $separator: JQuery;
    /**
     * Contains the width the cells of the column really have (only set in Chrome due to a Chrome bug, see Table._updateRealColumnWidths)
     * @internal
     */
    _realWidth: number;
    protected _tableColumnsChangedHandler: EventHandler<TableColumnMovedEvent | Event<Table>>;
    constructor();
    static DEFAULT_MIN_WIDTH: number;
    static SMALL_MIN_WIDTH: number;
    static NARROW_MIN_WIDTH: number;
    init(model: InitModelOf<this>): void;
    /**
     * Override this function in order to implement custom init logic.
     */
    protected _init(model: InitModelOf<this>): void;
    destroy(): void;
    /**
     * Override this function in order to implement custom destroy logic.
     */
    protected _destroy(): void;
    /** @internal */
    _setTable(table: Table): void;
    /**
     * Converts the vararg if it is of type string to an object with
     * a property 'text' with the original value.
     *
     * Example:
     * 'My Company' --> { text: 'MyCompany'; }
     *
     * @see JsonCell.java
     * @param vararg either a Cell instance or a scalar value
     */
    initCell(vararg: TValue | Cell<TValue>, row?: TableRow): Cell<TValue>;
    /**
     * Ensures that a Cell instance is returned.
     * When vararg is a scalar value a new Cell instance is created and the value is set as {@link cell.value} property.
     *
     * @param vararg either a Cell instance or a scalar value
     */
    private _ensureCell;
    /**
     * Override this method to create a value based on the given scalar value.
     */
    protected _parseValue(scalar: TValue): TValue;
    protected _updateCellText(row: TableRow, cell: Cell<TValue>): void;
    protected _formatValue(value: TValue, row?: TableRow): string | JQuery.Promise<string>;
    /**
     * If cell does not define properties, use column values.
     * Override this function to implement type specific init cell behavior.
     *
     */
    protected _initCell(cell: Cell<TValue>): Cell<TValue>;
    buildCellForRow(row: TableRow): string;
    buildCellForAggregateRow(aggregateRow: AggregateTableRow): string;
    buildCell(cell: Cell<TValue>, row: TableRow | {
        hasError?: boolean;
        expanded?: boolean;
        expandable?: boolean;
        parentRow?: TableRow;
    }): string;
    protected _buildCell(cell: Cell<TValue>, content: string, style: string, cssClass: string): string;
    protected _expandIcon(expanded: boolean, rowPadding: number): string;
    protected _icon(iconId: string, hasText: boolean): string;
    protected _text(cell: Cell<TValue>): string;
    protected _cellCssClass(cell: Cell<TValue>, tableNode?: boolean): string;
    protected _cellStyle(cell: Cell<TValue>, tableNodeColumn?: boolean, rowPadding?: number): string;
    onMouseUp(event: JQuery.MouseUpEvent, $row: JQuery): void;
    isCellEditable(row: TableRow, cell: Cell<TValue>, event: JQuery.MouseEventBase): boolean;
    startCellEdit(row: TableRow, field: ValueField<TValue>): CellEditorPopup<TValue>;
    protected _createEditorPopup(row: TableRow, cell: Cell<TValue>): CellEditorPopup<TValue>;
    /**
     * @returns the cell object for this column from the given row.
     */
    cell(row: TableRow): Cell<TValue>;
    /**
     * Creates an artificial cell from the properties relevant for the column header.
     */
    headerCell(): Cell<string>;
    /**
     * @returns the cell object for this column from the first selected row in the table.
     */
    selectedCell(): Cell<TValue>;
    /**
     * @returns the value of the cell. If it is text based as string otherwise the raw value.
     */
    cellValueOrText(row: TableRow): TValue | string;
    cellValue(row: TableRow): TValue | string;
    cellText(row: TableRow): string;
    /**
     * @returns the cell value to be used for grouping and filtering (chart, column filter).
     */
    cellValueOrTextForCalculation(row: TableRow): TValue | string;
    protected _preprocessValueOrTextForCalculation(value: TValue | string, cell?: Cell<TValue>): TValue | string;
    protected _preprocessTextForCalculation(text: string, htmlEnabled?: boolean): string;
    /**
     * @returns the cell text to be used for table grouping
     */
    cellTextForGrouping(row: TableRow): string;
    protected _preprocessTextForGrouping(text: string, htmlEnabled?: boolean): string;
    /**
     * @returns the cell text to be used for the text filter
     */
    cellTextForTextFilter(row: TableRow): string;
    protected _preprocessTextForTextFilter(text: string, htmlEnabled?: boolean): string;
    /**
     * @returns the cell text to be used for the table row detail.
     */
    cellTextForRowDetail(row: TableRow): string;
    /**
     * Removes html tags, converts to single line, removes leading and trailing whitespaces.
     */
    protected _preprocessText(text: string, options: {
        removeHtmlTags?: boolean;
        removeNewlines?: boolean;
        trim?: boolean;
    }): string;
    setCellValue(row: TableRow, value: TValue): void;
    protected _setCellValue(row: TableRow, value: TValue, cell: Cell<TValue>): void;
    setCellTextDeferred(promise: JQuery.Promise<string>, row: TableRow, cell: Cell<TValue>): void;
    setCellText(row: TableRow, text: string, cell?: Cell<TValue>): void;
    setCellErrorStatus(row: TableRow, errorStatus: Status, cell?: Cell<TValue>): void;
    setCellIconId(row: TableRow, iconId: string): void;
    setHorizontalAlignment(horizontalAlignment: Alignment): void;
    setEditable(editable: boolean): void;
    setMandatory(mandatory: boolean): void;
    setCssClass(cssClass: string): void;
    setWidth(width: number): void;
    createAggrGroupCell(row: TableRow): Cell<TValue>;
    createAggrValueCell(value: TValue): Cell<TValue>;
    createAggrEmptyCell(): Cell<TValue>;
    calculateOptimalWidth(): number | JQuery.Promise<number>;
    /**
     * Returns a type specific column user-filter. The default impl. returns a ColumnUserFilter.
     * Subclasses that must return another type, must simply change the value of the 'filterType' property.
     */
    createFilter(): ColumnUserFilter;
    /**
     * Returns a table header menu. Subclasses can override this method to create a column specific table header menu.
     */
    createTableHeaderMenu(tableHeader: TableHeader): TableHeaderMenu;
    /**
     * @returns a field instance used as editor when a cell of this column is in edit mode.
     */
    createEditor(row: TableRow): ValueField<TValue>;
    /**
     * Depending on the type of column the editor may need to be initialized differently.
     * The default implementation either copies the value to the field if the field has no error or copies the text and error status if it has an error.
     */
    protected _initEditorField(field: ValueField<TValue>, cell: Cell<TValue>): void;
    protected _updateEditorFromValidCell(field: ValueField<TValue>, cell: Cell<TValue>): void;
    protected _updateEditorFromInvalidCell(field: ValueField<TValue>, cell: Cell<TValue>): void;
    protected _createEditor(row: TableRow): ValueField<TValue, any>;
    updateCellFromEditor(row: TableRow, field: ValueField<TValue>): void;
    protected _updateCellFromInvalidEditor(row: TableRow, field: ValueField<TValue>): void;
    protected _updateCellFromValidEditor(row: TableRow, field: ValueField<TValue>): void;
    /**
     * Override this function to install a specific compare function on a column instance.
     * The default impl. installs a generic comparator working with less than and greater than.
     *
     * @returns whether or not it was possible to install a compare function. If not, client side sorting is disabled.
     */
    installComparator(): boolean;
    /**
     * @returns whether or not it is possible to sort this column. As a side effect a comparator is installed.
     */
    isSortingPossible(): boolean;
    compare(row1: TableRow, row2: TableRow): number;
    isVisible(): boolean;
    /**
     * @param redraw true, to redraw the table immediately, false if not. Default is {@link initialized}. When false is used, the redraw needs to be triggered manually using {@link Table.onColumnVisibilityChanged}.
     */
    setVisible(visible: boolean, redraw?: boolean): void;
    protected _setVisible(visible: boolean, redraw?: boolean): void;
    /**
     * @param redraw true, to redraw the table immediately, false if not. Default is {@link initialized}. When false is used, the redraw needs to be triggered manually using {@link Table.onColumnVisibilityChanged}.
     */
    setDisplayable(displayable: boolean, redraw?: boolean): void;
    protected _setDisplayable(displayable: boolean, redraw?: boolean): void;
    /**
     * @param redraw true, to redraw the table immediately, false if not. Default is {@link initialized}. When false is used, the redraw needs to be triggered manually using {@link Table.onColumnVisibilityChanged}.
     */
    setCompacted(compacted: boolean, redraw?: boolean): void;
    protected _setCompacted(compacted: boolean, redraw?: boolean): void;
    setAutoOptimizeWidth(autoOptimizeWidth: boolean): void;
    protected _setAutoOptimizeWidth(autoOptimizeWidth: boolean): void;
    setMaxLength(maxLength: number): void;
    setText(text: string): void;
    setHeaderIconId(headerIconId: string): void;
    setHeaderCssClass(headerCssClass: string): void;
    setHeaderHtmlEnabled(headerHtmlEnabled: boolean): void;
    setHeaderTooltipText(headerTooltipText: string): void;
    setHeaderTooltipHtmlEnabled(headerTooltipHtmlEnabled: boolean): void;
    setTextWrap(textWrap: boolean): void;
    isContentValid(row: TableRow): {
        valid: boolean;
        validByErrorStatus: boolean;
        validByMandatory: boolean;
    };
    protected _hasCellValue(cell: Cell<TValue>): boolean;
    protected _onTableColumnsChanged(event: TableColumnMovedEvent | Event<Table>): void;
    realWidthIfAvailable(): number;
}
//# sourceMappingURL=Column.d.ts.map