import { InitModelOf, Range, SomeRequired, VirtualScrollingModel, Widget } from '../index';
export declare class VirtualScrolling implements VirtualScrollingModel {
    model: VirtualScrollingModel;
    initModel: SomeRequired<this['model'], 'rowHeight' | 'rowCount' | '_renderViewRange'>;
    enabled: boolean;
    minRowHeight: number;
    viewRangeSize: number;
    widget: Widget;
    $scrollable: JQuery;
    constructor(options: InitModelOf<VirtualScrolling>);
    setEnabled(enabled: boolean): void;
    set$Scrollable($scrollable: JQuery): void;
    setMinRowHeight(minRowHeight: number): void;
    setViewRangeSize(viewRangeSize: number, updateViewPort?: boolean): void;
    /**
     * Calculates the optimal view range size (number of rows to be rendered).
     * It uses the default row height to estimate how many rows fit in the view port.
     * The view range size is this value * 2.
     */
    calculateViewRangeSize(): number;
    calculateCurrentViewRange(): Range;
    maxViewRange(): Range;
    /**
     * Returns a range of size {@link this.viewRangeSize}. Start of range is rowIndex - viewRangeSize / 4.
     * -> 1/4 of the rows are before the viewport 2/4 in the viewport 1/4 after the viewport,
     * assuming viewRangeSize is 2*number of possible rows in the viewport (see {@link calculateViewRangeSize}).
     */
    calculateViewRangeForRowIndex(rowIndex: number): Range;
    /**
     * Returns the index of the row which is at position scrollTop.
     */
    protected _rowIndexAtScrollTop(scrollTop: number): number;
    rowHeight(row: number): number;
    rowCount(): number;
    /**
     * Calculates and renders the rows which should be visible in the current viewport based on scroll top.
     */
    renderViewPort(): void;
    renderViewRangeForRowIndex(rowIndex: number): void;
    /**
     * Renders the rows visible in the viewport and removes the other rows
     */
    _renderViewRange(viewRange: Range): void;
}
//# sourceMappingURL=VirtualScrolling.d.ts.map