import { DateFormat, DateFormatContext, DateFormatParseContext, DateFormatPatternTypes } from '../index';
export interface DateFormatPatternDefinitionOptions {
    /**
     * The "group" where the pattern definition belongs to. E.g. "dd" and "d" belong to the same group "day".
     * This is used during analysis to find other definitions for the same type. Use one of the constants defined in {@link DateFormatPatternType}.
     */
    type?: DateFormatPatternTypes;
    /**
     * An array consisting of all pattern terms that this particular definition can handle.
     * Multiple terms with the same meaning may be accepted (e.g. "yyy", "yy" and "y" can be all used for a 2-digit year formatting, but different parsing rules may apply).
     */
    terms?: string[];
    /**
     * Reference to the corresponding dateFormat object.
     */
    dateFormat?: DateFormat;
    /**
     * An optional function that is used to format this particular term.
     *   @param formatContext
     *            See documentation at _createFormatContext().
     *   @param acceptedTerm
     *            The term that was accepted for this definition. This argument is usually only relevant,
     *            if a definition can accept more than one term.
     *   @returns The function may return a string as result. If a string is returned, it is appended to the formatContext.formattedString automatically. If the formatFunction already did this, it should return "undefined".
     */
    formatFunction?: (formatContext: DateFormatContext, acceptedTerm: string) => string;
    /**
     * A optional JavaScript RegExp object that is applied to the input string to extract this definition's term.
     * The expression _must_ use exactly two capturing groups:
     *   [1] = matched part of the input
     *   [2] = remaining input (will be parsed later by other definitions)
     * Example: /^(\d{4})(.*)$/
     */
    parseRegExp?: RegExp;
    /**
     * If 'parseRegExp' is set and found a match, and this function is defined, it is called to apply the matched part to the parseContext.
     *   @param parseContext
     *            See documentation at _createParseContext().
     *   @param match
     *            The first match from the reg exp.
     *   @param acceptedTerm
     *            The term that was accepted for this definition. This argument is usually only relevant, if a definition can accept more than one term.
     */
    applyMatchFunction?: (parseContext: DateFormatParseContext, match: string, acceptedTerm: string) => void;
    /**
     * If parsing is not possible with a regular expression, this function may be defined to execute more complex parse logic.
     *   @param parseContext
     *            See documentation at _createParseContext().
     *   @param acceptedTerm
     *            The term that was accepted for this definition. This argument is usually only relevant, if a definition can accept more than one term.
     *   @returns A string with the matched part of the input, or null if it did not match.
     */
    parseFunction?: (parseContext: DateFormatParseContext, acceptedTerm: string) => string;
}
/**
 * Definition of a date format pattern.
 */
export declare class DateFormatPatternDefinition implements DateFormatPatternDefinitionOptions {
    type: DateFormatPatternTypes;
    terms: string[];
    dateFormat: DateFormat;
    formatFunction: (formatContext: DateFormatContext, acceptedTerm: string) => string;
    parseRegExp: RegExp;
    applyMatchFunction: (parseContext: DateFormatParseContext, match: string, acceptedTerm: string) => void;
    parseFunction: (parseContext: DateFormatParseContext, acceptedTerm: string) => string;
    constructor(options: DateFormatPatternDefinitionOptions);
    createFormatFunction(acceptedTerm: string): (formatContext: DateFormatContext) => void;
    createParseFunction(acceptedTerm: string): (parseContext: DateFormatParseContext) => boolean;
    /**
     * @returns the accepted term (if is accepted) or null (if it is not accepted)
     */
    accept(term: string): string;
}
//# sourceMappingURL=DateFormatPatternDefinition.d.ts.map