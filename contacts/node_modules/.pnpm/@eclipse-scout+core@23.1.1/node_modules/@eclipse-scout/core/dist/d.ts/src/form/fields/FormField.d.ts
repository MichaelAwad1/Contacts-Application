/// <reference types="jquery" />
import { AbstractLayout, Action, CloneOptions, DragAndDropHandler, DragAndDropOptions, DropType, EnumObject, EventHandler, FieldStatus, FormFieldEventMap, FormFieldModel, GridData, GroupBox, InitModelOf, KeyStrokeContext, LoadingSupport, Menu, ObjectOrChildModel, Predicate, PropertyChangeEvent, Status, StatusMenuMapping, StatusOrModel, Tooltip, TooltipSupport, TreeVisitResult, Widget } from '../../index';
/**
 * Base class for all form-fields.
 */
export declare class FormField extends Widget implements FormFieldModel {
    model: FormFieldModel;
    eventMap: FormFieldEventMap;
    self: FormField;
    dropType: DropType;
    dropMaximumSize: number;
    empty: boolean;
    errorStatus: Status;
    fieldStyle: FormFieldStyle;
    gridData: GridData;
    gridDataHints: GridData;
    mode: FormFieldMode;
    fieldStatus: FieldStatus;
    keyStrokes: Action[];
    displayText: string;
    label: string;
    labelVisible: boolean;
    labelPosition: FormFieldLabelPosition;
    labelWidthInPixel: number;
    labelUseUiWidth: boolean;
    labelHtmlEnabled: boolean;
    mandatory: boolean;
    statusMenuMappings: StatusMenuMapping[];
    menus: Menu[];
    menusVisible: boolean;
    defaultMenuTypes: string[];
    preventInitialFocus: boolean;
    requiresSave: boolean;
    statusPosition: FormFieldStatusPosition;
    statusVisible: boolean;
    suppressStatus: FormFieldSuppressStatus;
    touched: boolean;
    tooltipText: string;
    font: string;
    foregroundColor: string;
    backgroundColor: string;
    labelFont: string;
    labelForegroundColor: string;
    labelBackgroundColor: string;
    tooltipAnchor: FormFieldTooltipAnchor;
    onFieldTooltipOptionsCreator: (this: FormField) => InitModelOf<TooltipSupport>;
    dragAndDropHandler: DragAndDropHandler;
    /**
     * Some browsers don't support copying text from disabled input fields. If such a browser is detected
     * and this flag is true (default is false), an overlay DIV is rendered over disabled fields which
     * provides a custom copy context menu that opens the ClipboardForm.
     */
    disabledCopyOverlay: boolean;
    $label: JQuery;
    /**
     * Note the difference between $field and $fieldContainer:
     * - $field points to the input-field (typically a browser-text field)
     * - $fieldContainer could point to the same input-field or when the field is a composite,
     *   to the parent DIV of that composite. For instance: the multi-line-smartfield is a
     *   composite with a input-field and a DIV showing the additional lines. In that case $field
     *   points to the input-field and $fieldContainer to the parent DIV of the input-field.
     *   This property should be used primarily for layout-functionality.
     */
    $field: JQuery;
    $clearIcon: JQuery;
    $fieldContainer: JQuery;
    $icon: JQuery;
    $pseudoStatus: JQuery;
    /**
     * The status is used for error-status, tooltip-icon and menus.
     */
    $status: JQuery;
    $mandatory: JQuery;
    $disabledCopyOverlay: JQuery;
    protected _menuPropertyChangeHandler: EventHandler<PropertyChangeEvent<any, Menu>>;
    constructor();
    static FieldStyle: {
        readonly CLASSIC: "classic";
        readonly ALTERNATIVE: "alternative";
    };
    static SuppressStatus: {
        /**
         * Suppress status on icon and field (CSS class).
         */
        readonly ALL: "all";
        /**
         * Suppress status on icon, but still show status on field (CSS class).
         */
        readonly ICON: "icon";
        /**
         * Suppress status on field (CSS class), but still show status as icon.
         */
        readonly FIELD: "field";
    };
    /** Global variable to make it easier to adjust the default field style for all fields */
    static DEFAULT_FIELD_STYLE: "alternative";
    static StatusPosition: {
        readonly DEFAULT: "default";
        readonly TOP: "top";
    };
    static LabelPosition: {
        readonly DEFAULT: 0;
        readonly LEFT: 1;
        readonly ON_FIELD: 2;
        readonly RIGHT: 3;
        readonly TOP: 4;
        readonly BOTTOM: 5;
    };
    static TooltipAnchor: {
        readonly DEFAULT: "default";
        readonly ON_FIELD: "onField";
    };
    static LabelWidth: {
        readonly DEFAULT: 0;
        readonly UI: -1;
    };
    static FULL_WIDTH: number;
    static Mode: {
        readonly DEFAULT: "default";
        readonly CELLEDITOR: "celleditor";
    };
    static SEVERITY_CSS_CLASSES: string;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _createLoadingSupport(): LoadingSupport;
    protected _init(model: InitModelOf<this>): void;
    protected _initProperty(propertyName: string, value: any): void;
    /**
     * This function <strong>extends</strong> the default grid data hints of the form field.
     * The default values for grid data hints are set in the constructor of the FormField and its subclasses.
     * When the given gridDataHints is a plain object, we extend our default values. When gridDataHints is
     * already instanceof GridData we overwrite default values completely.
     */
    private _initGridDataHints;
    /**
     * All subclasses of FormField should implement a _render method. It should call the various add* methods provided by the FormField class.
     *
     * A possible _render implementation could look like this.
     * <pre>
     * this.addContainer(this.$parent, 'form-field');
     * this.addLabel();
     * this.addField(this.$parent.makeDiv('foo', 'bar'));
     * this.addMandatoryIndicator();
     * this.addStatus();
     * </pre>
     */
    protected _render(): void;
    protected _renderProperties(): void;
    protected _remove(): void;
    /** @see FormFieldModel.fieldStyle */
    setFieldStyle(fieldStyle: FormFieldStyle): void;
    protected _renderFieldStyle(): void;
    protected _renderFieldStyleInternal($element: JQuery): void;
    /** @see FormFieldModel.mandatory */
    setMandatory(mandatory: boolean): void;
    protected _renderMandatory(): void;
    /**
     * Override this function to return another error status property.
     * The default implementation returns the property 'errorStatus'.
     *
     */
    protected _errorStatus(): Status;
    /** @see FormFieldModel.errorStatus */
    setErrorStatus(errorStatus: StatusOrModel): void;
    protected _setErrorStatus(errorStatus: StatusOrModel): void;
    /**
     * Adds the given (functional) error status to the list of error status. Prefer this function over #setErrorStatus
     * when you don't want to mess with the internal error states of the field (parsing, validation).
     *
     */
    addErrorStatus(errorStatus: string | Status): void;
    /**
     * Create an error status with severity {@link Status.Severity.ERROR} containing the given message.
     *
     * @param message The message for the error status.
     * @returns containing the given message.
     */
    protected _createErrorStatus(message: string): Status;
    /**
     * Whether or not the error status is or has the given status type.
     */
    containsStatus(statusType: new () => Status): boolean;
    /** @see FormFieldModel.suppressStatus */
    setSuppressStatus(suppressStatus: FormFieldSuppressStatus): void;
    protected _renderSuppressStatus(): void;
    /**
     * @returns Whether or not error status icon is suppressed
     */
    protected _isSuppressStatusIcon(): boolean;
    /**
     * @returns Whether or not error status CSS class is suppressed on field
     */
    protected _isSuppressStatusField(): boolean;
    /**
     * Removes all status (incl. children) with the given type.
     */
    removeErrorStatus(statusType: new () => Status): void;
    removeErrorStatusByPredicate(predicate: Predicate<Status>): void;
    clearErrorStatus(): void;
    /** @internal */
    _renderErrorStatus(): void;
    protected _updateErrorStatusClasses(statusClass: string, hasStatus: boolean): void;
    protected _updateErrorStatusClassesOnElement($element: JQuery, statusClass: string, hasStatus: boolean): void;
    /** @see FormFieldModel.tooltipText */
    setTooltipText(tooltipText: string): void;
    /** @internal */
    _renderTooltipText(): void;
    /** @see FormFieldModel.tooltipAnchor */
    setTooltipAnchor(tooltipAnchor: FormFieldTooltipAnchor): void;
    protected _renderTooltipAnchor(): void;
    protected _updateTooltip(): void;
    hasStatusTooltip(): boolean;
    hasOnFieldTooltip(): boolean;
    /** @see FormFieldModel.onFieldTooltipOptionsCreator */
    setOnFieldTooltipOptionsCreator(onFieldTooltipOptionsCreator: (this: FormField) => InitModelOf<TooltipSupport>): void;
    protected _createOnFieldTooltipOptions(): InitModelOf<TooltipSupport>;
    protected _renderVisible(): void;
    /** @see FormFieldModel.label */
    setLabel(label: string): void;
    protected _renderLabel(): void;
    /**
     * Renders an empty label for button-like fields that don't have a regular label but which do want to support the 'labelVisible'
     * property in order to provide some layout-flexibility. Makes sure the empty label has the same height as the other labels,
     * which is especially important for top labels.
     */
    protected _renderEmptyLabel(): void;
    protected _renderPlaceholder($field?: JQuery): void;
    /**
     * @param $field argument is required by DateField.js, when not set this.$field is used
     */
    protected _removePlaceholder($field?: JQuery): void;
    /** @see FormFieldModel.labelVisible */
    setLabelVisible(visible: boolean): void;
    protected _renderLabelVisible(): void;
    /** @see FormFieldModel.labelWidthInPixel */
    setLabelWidthInPixel(labelWidthInPixel: number): void;
    protected _renderLabelWidthInPixel(): void;
    /** @see FormFieldModel.labelUseUiWidth */
    setLabelUseUiWidth(labelUseUiWidth: number): void;
    protected _renderLabelUseUiWidth(): void;
    /** @see FormFieldModel.statusVisible */
    setStatusVisible(visible: boolean): void;
    protected _renderStatusVisible(): void;
    /** @see FormFieldModel.statusPosition */
    setStatusPosition(statusPosition: FormFieldStatusPosition): void;
    protected _renderStatusPosition(): void;
    /**
     * The tooltip of the {@link fieldStatus}, if it is shown.
     */
    tooltip(): Tooltip;
    protected _updateFieldStatus(): void;
    protected _isInitialShowStatus(): boolean;
    /**
     * Computes whether the $status should be visible based on statusVisible, errorStatus and tooltip.
     * -> errorStatus and tooltip override statusVisible, so $status may be visible event though statusVisible is set to false
     */
    protected _computeStatusVisible(): boolean;
    protected _renderChildVisible($child: JQuery, visible: boolean): boolean;
    /** @see FormFieldModel.labelPosition */
    setLabelPosition(labelPosition: FormFieldLabelPosition): void;
    protected _renderLabelPosition(): void;
    /** @see FormFieldModel.labelHtmlEnabled */
    setLabelHtmlEnabled(labelHtmlEnabled: boolean): void;
    protected _renderLabelHtmlEnabled(): void;
    protected _renderEnabled(): void;
    protected _renderDisabledStyle(): void;
    /** @see FormFieldModel.font */
    setFont(font: string): void;
    protected _renderFont(): void;
    /** @see FormFieldModel.foregroundColor */
    setForegroundColor(foregroundColor: string): void;
    protected _renderForegroundColor(): void;
    /** @see FormFieldModel.backgroundColor */
    setBackgroundColor(backgroundColor: string): void;
    protected _renderBackgroundColor(): void;
    /** @see FormFieldModel.labelFont */
    setLabelFont(labelFont: string): void;
    protected _renderLabelFont(): void;
    /** @see FormFieldModel.labelForegroundColor */
    setLabelForegroundColor(labelForegroundColor: string): void;
    protected _renderLabelForegroundColor(): void;
    /** @see FormFieldModel.labelBackgroundColor */
    setLabelBackgroundColor(labelBackgroundColor: string): void;
    protected _renderLabelBackgroundColor(): void;
    /** @see FormFieldModel.gridDataHints */
    setGridDataHints(gridData: GridData): void;
    protected _setGridDataHints(gridData: GridData): void;
    protected _renderGridDataHints(): void;
    /** @internal */
    _setGridData(gridData: GridData): void;
    protected _renderGridData(): void;
    /** @see FormFieldModel.menus */
    setMenus(menus: ObjectOrChildModel<Menu>[]): void;
    protected _setMenus(menus: Menu | Menu[]): void;
    insertMenu(menuToInsert: ObjectOrChildModel<Menu>): void;
    insertMenus(menusToInsert: ObjectOrChildModel<Menu>[]): void;
    deleteMenu(menuToDelete: Menu): void;
    deleteMenus(menusToDelete: Menu[]): void;
    protected _onMenuPropertyChange(event: PropertyChangeEvent<any, Menu>): void;
    getContextMenuItems(onlyVisible?: boolean): Menu[];
    protected _getMenusForStatus(status: Status): Menu[];
    protected _hasMenus(): boolean;
    /** @internal */
    _updateMenus(): void;
    /** @internal */
    _renderMenus(): void;
    protected _renderStatusMenuMappings(): void;
    setMenusVisible(menusVisible: boolean): void;
    protected _setMenusVisible(menusVisible: boolean): void;
    protected _renderMenusVisible(): void;
    getCurrentMenuTypes(): string[];
    protected _getCurrentMenuTypes(): string[];
    protected _setKeyStrokes(keyStrokes: Action[]): void;
    /**
     * May be overridden to explicitly provide a tooltip $parent
     * @internal
     */
    _$tooltipParent(): JQuery;
    /** @internal */
    _hideStatusMessage(): void;
    protected _renderPreventInitialFocus(): void;
    /**
     * Sets the focus on this field. If the field is not rendered, the focus will be set as soon as it is rendered.
     * @returns true if the element could be focused, false if not
     */
    focus(): boolean;
    /**
     * This method returns the HtmlElement to be used as initial focus element or when {@link #focus()} is called.
     * It can be overridden, in case the FormField needs to return something other than this.$field[0].
     */
    getFocusableElement(): HTMLElement | JQuery;
    protected _onFieldFocus(event: JQuery.FocusEvent): void;
    protected _onFieldBlur(event: JQuery.BlurEvent): void;
    /**
     * When calling this function, the same should happen as when clicking into the field. It is used when the label is clicked.<br>
     * The most basic action is focusing the field but this may differ from field to field.
     */
    activate(): void;
    get$Scrollable(): JQuery;
    getParentGroupBox(): GroupBox;
    getParentField(): Widget;
    /**
     * Appends a LABEL element to this.$container and sets the this.$label property.
     */
    addLabel(): void;
    protected _onLabelClick(event: JQuery.ClickEvent): void;
    protected _removeLabel(): void;
    /**
     * Links the given element with the label by setting aria-labelledby.<br>
     * This allows screen readers to build a catalog of the elements on the screen and their relationships, for example, to read the label when the input is focused.
     */
    protected _linkWithLabel($element: JQuery): void;
    protected _removeIcon(): void;
    /**
     * Appends the given field to the this.$container and sets the property this.$field.
     * The $field is used as $fieldContainer as long as you don't explicitly call addFieldContainer before calling addField.
     */
    addField($field: JQuery): void;
    /**
     * Call this method before addField if you'd like to have a different field container than $field.
     */
    addFieldContainer($fieldContainer: JQuery): void;
    /**
     * Removes this.$field and this.$fieldContainer and sets the properties to null.
     */
    protected _removeField(): void;
    /**
     * Appends a SPAN element for form-field status to this.$container and sets the this.$status property.
     */
    addStatus(): void;
    protected _removeStatus(): void;
    /**
     * Appends a SPAN element to this.$container and sets the this.$pseudoStatus property.
     * The purpose of a pseudo status is to consume the space an ordinary status would.
     * This makes it possible to make components without a status as width as components with a status.
     */
    addPseudoStatus(): void;
    addMandatoryIndicator(): void;
    removeMandatoryIndicator(): void;
    /**
     * Adds a SPAN element with class 'icon' the the given optional $parent.
     * When $parent is not set, the element is added to this.$container.
     */
    addIcon($parent?: JQuery): void;
    protected _onIconMouseDown(event: JQuery.MouseDownEvent): void;
    /**
     * Appends a DIV element as form-field container to $parent and sets the this.$container property.
     * Applies FormFieldLayout to this.$container (if container does not define another layout).
     * Sets this.htmlComp to the HtmlComponent created for this.$container.
     *
     * @param $parent to which container is appended
     * @param cssClass cssClass to add to the new container DIV
     * @param layout when layout is undefined, {@link _createLayout} is called
     *
     */
    addContainer($parent: JQuery, cssClass?: string, layout?: AbstractLayout): void;
    /**
     * @returns the default layout FormFieldLayout. Override this function if your field needs another layout.
     */
    protected _createLayout(): AbstractLayout;
    /**
     * Updates the "inner alignment" of a field. Usually, the GridData hints only have influence on the LogicalGridLayout.
     * However, the properties "horizontalAlignment" and "verticalAlignment" are sometimes used differently.
     * Instead of controlling the field alignment in case fillHorizontal/fillVertical is false, the developer expects the _contents_ of the field to be aligned correspondingly inside the field.
     * Technically, this is not correct, but is supported for legacy and convenience reasons for some of the Scout fields.
     * Those who support the behavior may override _renderGridData() and call this method.
     * Some CSS classes are then added to the field.
     */
    updateInnerAlignment(opts?: FormFieldAlignmentUpdateOptions): void;
    protected _updateElementInnerAlignment(opts: FormFieldAlignmentUpdateOptions, $field: JQuery): void;
    addCellEditorFieldCssClasses($field: JQuery, opts: AddCellEditorFieldCssClassesOptions): void;
    prepareForCellEdit(opts?: AddCellEditorFieldCssClassesOptions): void;
    /** @see FormFieldModel.dropType */
    setDropType(dropType: DropType): void;
    protected _renderDropType(): void;
    /** @see FormFieldModel.dropMaximumSize */
    setDropMaximumSize(dropMaximumSize: number): void;
    protected _installOrUninstallDragAndDropHandler(): void;
    protected _getDragAndDropHandlerOptions(): DragAndDropOptions;
    protected _updateDisabledCopyOverlay(): void;
    protected _renderDisabledCopyOverlay(): void;
    protected _removeDisabledCopyOverlay(): void;
    protected _createCopyContextMenu(event: JQuery.ContextMenuEvent): void;
    /**
     * Visits this field and all child form fields in pre-order (top-down).
     *
     * @returns the TreeVisitResult, or nothing to continue.
     */
    visitFields(visitor: (field: FormField) => TreeVisitResult | void): TreeVisitResult | void;
    /**
     * Visit all parent form fields. The visit stops if the parent is no form field anymore (e.g. a form, desktop or session).
     *
     */
    visitParentFields(visitor: (parent: FormField) => void): void;
    /** @see FormFieldModel.touched */
    markAsSaved(): void;
    /** @see FormFieldModel.touched */
    touch(): void;
    /**
     * Updates the {@link requiresSave} property by checking if the field is touched or if {@link computeRequiresSave} returns true.
     */
    updateRequiresSave(): void;
    /**
     * Override this function to provide a custom logic to compute the {@link requiresSave} state if the field is not {@link touched}, see {@link updateRequiresSave}.
     */
    computeRequiresSave(): boolean;
    getValidationResult(): ValidationResult;
    protected _updateEmpty(): void;
    requestInput(): void;
    clone(model: FormFieldModel, options?: CloneOptions): this;
    exportToClipboard(): void;
    protected _exportToClipboard(text: string): void;
}
export type FormFieldStyle = EnumObject<typeof FormField.FieldStyle>;
export type FormFieldSuppressStatus = EnumObject<typeof FormField.SuppressStatus>;
export type FormFieldStatusPosition = EnumObject<typeof FormField.StatusPosition>;
export type FormFieldLabelPosition = EnumObject<typeof FormField.LabelPosition>;
export type FormFieldTooltipAnchor = EnumObject<typeof FormField.TooltipAnchor>;
export type FormFieldLabelWidth = EnumObject<typeof FormField.LabelWidth>;
export type FormFieldMode = EnumObject<typeof FormField.Mode>;
export type FormFieldAlignmentUpdateOptions = {
    /**
     * When this option is true, "halign-" classes are added according to gridData.horizontalAlignment. Default is true.
     */
    useHorizontalAlignment?: boolean;
    /**
     * When this option is true, "valign-" classes are added according to gridData.verticalAlignment. Default is true.
     */
    useVerticalAlignment?: boolean;
    /**
     * Specifies the div where the classes should be added. If omitted, this.$fieldContainer is used.
     */
    $fieldContainer?: JQuery;
};
export type ValidationResult = {
    valid: boolean;
    validByErrorStatus: boolean;
    validByMandatory: boolean;
    field: FormField;
    label: string;
    reveal: () => void;
};
export type AddCellEditorFieldCssClassesOptions = {
    cssClass?: string;
};
//# sourceMappingURL=FormField.d.ts.map